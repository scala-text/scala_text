
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>エラー処理 · Scala研修テキスト</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-forkmegithub/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="implicit.html" />
    
    
    <link rel="prev" href="case-class-and-pattern-matching.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="introduction-to-scala.html">
            
                <a href="introduction-to-scala.html">
            
                    
                    Scalaとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="sbt-install.html">
            
                <a href="sbt-install.html">
            
                    
                    sbtをインストールする
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="basic.html">
            
                <a href="basic.html">
            
                    
                    Scalaの基本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="sbt-compile-execute.html">
            
                <a href="sbt-compile-execute.html">
            
                    
                    sbtでプログラムをコンパイル・実行する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="IDE.html">
            
                <a href="IDE.html">
            
                    
                    IDE(IntelliJ IDEA)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="notation.html">
            
                <a href="notation.html">
            
                    
                    記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="control-syntax.html">
            
                <a href="control-syntax.html">
            
                    
                    Scalaの制御構文
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="class.html">
            
                <a href="class.html">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="object.html">
            
                <a href="object.html">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="trait.html">
            
                <a href="trait.html">
            
                    
                    トレイト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="type-parameter.html">
            
                <a href="type-parameter.html">
            
                    
                    型パラメータと変位指定
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="function.html">
            
                <a href="function.html">
            
                    
                    関数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="collection.html">
            
                <a href="collection.html">
            
                    
                    コレクションライブラリ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="case-class-and-pattern-matching.html">
            
                <a href="case-class-and-pattern-matching.html">
            
                    
                    ケースクラスとパターンマッチング
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.16" data-path="error-handling.html">
            
                <a href="error-handling.html">
            
                    
                    エラー処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="implicit.html">
            
                <a href="implicit.html">
            
                    
                    Implicit
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="introduction-to-typeclass.html">
            
                <a href="introduction-to-typeclass.html">
            
                    
                    型クラスへの誘い
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="future-and-promise.html">
            
                <a href="future-and-promise.html">
            
                    
                    FutureとPromise
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="test.html">
            
                <a href="test.html">
            
                    
                    テスト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="java-interop.html">
            
                <a href="java-interop.html">
            
                    
                    Javaとの相互運用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="exercises.html">
            
                <a href="exercises.html">
            
                    
                    S99の案内
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="advanced-trait-di.html">
            
                <a href="advanced-trait-di.html">
            
                    
                    トレイトの応用編：依存性の注入によるリファクタリング
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="typeclass.html">
            
                <a href="typeclass.html">
            
                    
                    付録：様々な型クラスの紹介
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >エラー処理</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><h1 id="エラー処理"><a name="エラー処理" class="plugin-anchor" href="#エラー処理"><i class="fa fa-link" aria-hidden="true"></i></a>エラー処理</h1>
<p>ここではScalaにおけるエラー処理の基本を学びます。Scalaでのエラー処理は例外を使う方法と、OptionやEitherやTryなどのデータ型を使う方法があります。この2つの方法はどちらか一方だけを使うわけではなく、状況に応じて使いわけることになります。</p>
<p>まずは私たちが扱わなければならないエラーとエラー処理の性質について確認しましょう。</p>
<h2 id="エラーとは"><a name="エラーとは" class="plugin-anchor" href="#エラーとは"><i class="fa fa-link" aria-hidden="true"></i></a>エラーとは</h2>
<p>プログラムにとって、エラーというものにはどういったものがあるのか考えてみます。</p>
<h3 id="ユーザーからの入力"><a name="ユーザーからの入力" class="plugin-anchor" href="#ユーザーからの入力"><i class="fa fa-link" aria-hidden="true"></i></a>ユーザーからの入力</h3>
<p>1つはユーザーから受け取る不正な入力です。たとえば以下のようなものが考えられます。</p>
<ul>
<li>文字数が長すぎる</li>
<li>電話番号に文字列を使うなど、正しいフォーマットではない</li>
<li>既に登録されているユーザー名を使おうとしている</li>
</ul>
<p>など色々な問題が考えられます。また悪意のある攻撃者から攻撃を受けることもあります。</p>
<ul>
<li>アクセスを制限しているデータを見ようとしている</li>
<li>ログインセッションのCookieを改変する</li>
<li>大量にアクセスをおこない、システムを利用不能にしようとする</li>
</ul>
<p>基本的に外から受け取るデータはすべてエラーの原因となりえるので注意が必要です。</p>
<h3 id="外部サービスのエラー"><a name="外部サービスのエラー" class="plugin-anchor" href="#外部サービスのエラー"><i class="fa fa-link" aria-hidden="true"></i></a>外部サービスのエラー</h3>
<p>自分たちのプログラムが利用する外部サービスのエラーも考えられます。</p>
<ul>
<li>TwitterやFacebookに投稿しようとしても繋がらない</li>
<li>iPhoneやAndroidと通信しようとしても回線の都合で切れてしまう</li>
<li>ユーザーにメールを送信しようとしても失敗する</li>
</ul>
<p>以上のように外部のサービスを使わなければならないような処理はすべて失敗することを想定したほうがいいでしょう。</p>
<h3 id="内部のエラー"><a name="内部のエラー" class="plugin-anchor" href="#内部のエラー"><i class="fa fa-link" aria-hidden="true"></i></a>内部のエラー</h3>
<p>外的な要因だけではなく、内部の要因でエラーが発生することもあります。</p>
<ul>
<li>ライブラリのバグや自分たちのバグにより、プログラム全体が終了してしまう</li>
<li>MySQLやRedisなどの内部で利用しているサーバーが終了してしまう</li>
<li>メモリやディスク容量が足りない</li>
<li>処理に非常に大きな時間がかかってしまう</li>
</ul>
<p>内部のエラーは扱うことが難しい場合が多いですが、起こりうることは念頭に置くべきです。</p>
<h2 id="エラー処理で実現しなければならないこと"><a name="エラー処理で実現しなければならないこと" class="plugin-anchor" href="#エラー処理で実現しなければならないこと"><i class="fa fa-link" aria-hidden="true"></i></a>エラー処理で実現しなければならないこと</h2>
<p>以上のようなエラーに対して、私たちが行わなければいけないことを挙げてみます。</p>
<h3 id="例外安全性"><a name="例外安全性" class="plugin-anchor" href="#例外安全性"><i class="fa fa-link" aria-hidden="true"></i></a>例外安全性</h3>
<p>エラー処理の中の1つの例外処理には「例外安全性」という概念があります。例外が発生してもシステムがダウンしたり、データの不整合などの問題が起きない場合、例外安全と言います。</p>
<p>この概念はエラー処理全般にもあてはまります。私たちが作るプログラムを継続的に動作させたいと考えた場合、ユーザーの入力や外部サービスの問題により、システムダウンやデータの不整合が起きてはなりません。これがエラー処理の第一の目的になります。</p>
<h3 id="強い例外安全性"><a name="強い例外安全性" class="plugin-anchor" href="#強い例外安全性"><i class="fa fa-link" aria-hidden="true"></i></a>強い例外安全性</h3>
<p>例外安全性にはさらに強い概念として「強い例外安全性」というものがあります。これは例外が発生した場合、すべての状態が例外発生前に戻らなければならないという制約です。一般的にはこの制約を満たすことは難しいのですが、たとえばユーザーがサービスに課金して、何らかのエラーが生じた場合、確実にエラーを検出し、課金処理を取り消さなければなりません。どのような処理に強い例外安全性が求められるか判断し、どのように実現するかを考える必要があります。</p>
<h2 id="javaにおけるエラー処理"><a name="javaにおけるエラー処理" class="plugin-anchor" href="#javaにおけるエラー処理"><i class="fa fa-link" aria-hidden="true"></i></a>Javaにおけるエラー処理</h2>
<p>Javaのエラー処理の方法はScalaにも適用できるものが多いです。ここではJavaのエラー処理の注意点についていくつか復習しましょう。</p>
<h3 id="nullを返すことでエラーを表現する場合の注意点"><a name="nullを返すことでエラーを表現する場合の注意点" class="plugin-anchor" href="#nullを返すことでエラーを表現する場合の注意点"><i class="fa fa-link" aria-hidden="true"></i></a>nullを返すことでエラーを表現する場合の注意点</h3>
<p>Javaでは、変数が未初期化である場合や、コレクションライブラリが空なのに要素を取得しようとした場合など、nullでエラーを表現することがあります。
Javaはプリミティブ型以外の参照型はすべてnullにすることができます。この性質はエラー値を他に用意する必要がないという点では便利なのですが、しばしば返り値をnullかどうかチェックするのを忘れて実行時エラーの<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/lang/NullPointerException.html" target="_blank">NullPointerException</a>（通称：ぬるぽ・NPE）を発生させてしまいます。（「ぬるぽ」と「ガッ」というやりとりをする2chの文化の語源でもあります）</p>
<p>参照型がすべて<code>null</code>になりうるということは、メソッドが<code>null</code>が返されるかどうかはメソッドの型からはわからないので、Javaのメソッドで<code>null</code>を返す場合はドキュメントに書くようにしましょう。そして、<code>null</code>をエラー値に使うエラー処理は暗黙的なエラー状態をシステムのいたるところに持ち込むことになり、発見困難なバグを生む要因になります。後述しますが、ScalaではOptionというデータ構造を使うことでこの問題を解決します。</p>
<h3 id="例外を投げる場合の注意点"><a name="例外を投げる場合の注意点" class="plugin-anchor" href="#例外を投げる場合の注意点"><i class="fa fa-link" aria-hidden="true"></i></a>例外を投げる場合の注意点</h3>
<p>Javaのエラー処理で中心的な役割を果たすのが例外です。例外は今実行している処理を中断し、大域的に実行を移動できる便利な機能ですが、濫用することで処理の流れがわかりづらいコードにもなります。例外はエラー状態にのみ利用し、メソッドが正常な値を返す場合には使わないようにしましょう。</p>
<h3 id="チェック例外の注意点"><a name="チェック例外の注意点" class="plugin-anchor" href="#チェック例外の注意点"><i class="fa fa-link" aria-hidden="true"></i></a>チェック例外の注意点</h3>
<p>Javaにはメソッドに<code>throws</code>節を付けることで、メソッドを使う側に例外を処理することを強制するチェック例外という機能もあります。チェック例外は例外の発生を表現し、コンパイラにチェックさせるという点で便利な機能ですが、上げられた例外のcatch処理はわずらわしいものにもなりえます。使う側が適切に処理できない例外を上げられた場合はあまり意味のないエラー処理コードを書かざるをえません。よってチェック例外は利用側がcatchして適切にエラー状態から回復できる場合にのみ利用したほうがいいでしょう。</p>
<h3 id="例外翻訳の注意点"><a name="例外翻訳の注意点" class="plugin-anchor" href="#例外翻訳の注意点"><i class="fa fa-link" aria-hidden="true"></i></a>例外翻訳の注意点</h3>
<p>Javaの例外は実装の変更により変化する場合があります。たとえば今までHTTPで取得していたデータをMySQLに保存したとしましょう。その場合、今まではHTTPExceptionが投げられていたものが、SQLExceptionが投げられるようになるかもしれません。すると、この例外をcatchする側もHTTPExceptionではなくSQLExceptionを扱うようにしなければなりません。このように低レベルの実装の変更がプログラム全体に影響することがありえます。</p>
<p>そのような問題を防ぐために途中の層で一度例外をcatchし、適切な例外で包んでもう一度投げる手法があります。このことを例外翻訳と呼びます。例外翻訳は例外に対する情報を増やし、catchする側の影響も少なくする手法です。ただし、この例外翻訳も乱用すると例外の種類が増えて例外処理が煩雑になる可能性もあるので注意が必要です。</p>
<h3 id="例外をドキュメントに書く"><a name="例外をドキュメントに書く" class="plugin-anchor" href="#例外をドキュメントに書く"><i class="fa fa-link" aria-hidden="true"></i></a>例外をドキュメントに書く</h3>
<p>例外はチェック例外でない場合、APIから読み取ることができません。さらに後述しますがScalaではチェック例外がないので、メソッドの型からどんな例外を投げるかは判別できません。そのためAPIドキュメントには発生しうる例外についても書いておいたほうが良いでしょう。</p>
<h2 id="例外の問題点"><a name="例外の問題点" class="plugin-anchor" href="#例外の問題点"><i class="fa fa-link" aria-hidden="true"></i></a>例外の問題点</h2>
<p>Javaのエラー処理では例外が中心的な役割を担っていましたが、Scalaでも例外は多く使われます。しかし、例外は便利な反面、様々な問題もあります。ここで例外の問題点を把握し、適切に使えるようになりましょう。</p>
<h3 id="例外を使うと制御の流れがわかりづらくなる"><a name="例外を使うと制御の流れがわかりづらくなる" class="plugin-anchor" href="#例外を使うと制御の流れがわかりづらくなる"><i class="fa fa-link" aria-hidden="true"></i></a>例外を使うと制御の流れがわかりづらくなる</h3>
<p>先ほど述べたように例外は、適切に使えば正常系の処理とエラー処理を分離し、コードの可読性を上げ、エラー処理をまとめる効果があります。しかし、往々にして例外のcatch漏れが発生し、障害に繋がることがあります。逆に例外をcatchしているところで、どこで発生した例外をcatchしているのか判別できないために、コードの修正を阻害する場合もあります。</p>
<h3 id="例外は非同期プログラミングでは扱いづらい"><a name="例外は非同期プログラミングでは扱いづらい" class="plugin-anchor" href="#例外は非同期プログラミングでは扱いづらい"><i class="fa fa-link" aria-hidden="true"></i></a>例外は非同期プログラミングでは扱いづらい</h3>
<p>例外の基本メカニズムは、送出されたらcatchされるまで（同一スレッドの）コールスタックを遡っていくというものです。これは、素直に考えると別スレッドで発生した例外を取り扱うことが難しいということを意味しています。別スレッドで発生した例外を取り扱うメカニズムを考えることも可能ですが、既存の例外の仕組みをそのまま使えないことは確かです。特にScalaでは非同期プログラミングが多用されるので、例外をそのまま使えないことが多いです。</p>
<h3 id="例外は型チェックできない"><a name="例外は型チェックできない" class="plugin-anchor" href="#例外は型チェックできない"><i class="fa fa-link" aria-hidden="true"></i></a>例外は型チェックできない</h3>
<p>チェック例外を使わない限り、どんな例外が発生するのかメソッドの型としては表現されません。またcatchする側でも間違った例外をキャッチしているかどうかは実行時にしかわかりません。例外に頼りすぎると静的型付き言語の利点が損われます。</p>
<h3 id="チェック例外の問題点"><a name="チェック例外の問題点" class="plugin-anchor" href="#チェック例外の問題点"><i class="fa fa-link" aria-hidden="true"></i></a>チェック例外の問題点</h3>
<p>チェック例外を使わないとコンパイル時に型チェックできないわけですが、ScalaではJavaとは違いチェック例外の機能はなくなりました。これにはチェック例外の様々な問題点が理由としてあると思います</p>
<ul>
<li>高階関数でチェック例外を扱うことが難しい</li>
<li>ボイラープレートが増える</li>
<li>例外によるメソッド型の変更を防ぐために例外翻訳を多用せざるをえない</li>
</ul>
<p>特にScalaでは1番目の問題が大きいと思います。後述しますが、Scalaではチェック例外の代替手段として、エラーを表現するデータ型を使い、エラー処理を型安全にすることもできます。それらを考えるとScalaでチェック例外をなくしたのは妥当な判断と言えるでしょう。</p>
<h2 id="エラーを表現するデータ型を使った処理"><a name="エラーを表現するデータ型を使った処理" class="plugin-anchor" href="#エラーを表現するデータ型を使った処理"><i class="fa fa-link" aria-hidden="true"></i></a>エラーを表現するデータ型を使った処理</h2>
<p>例外に問題があるとすれば、どのようにエラーを扱えばよいのでしょうか。その答えの1つはエラーを例外ではなく、メソッドの返り値で返せるような値にすることです。</p>
<p>ここでは正常の値とエラー値のどちらかを表現できるデータ構造の紹介を通じて、Scalaの関数型のエラー処理の方法を見ていきます。</p>
<h3 id="option"><a name="option" class="plugin-anchor" href="#option"><i class="fa fa-link" aria-hidden="true"></i></a><a href="https://github.com/scala/scala/blob/v2.13.16/src/library/scala/Option.scala" target="_blank">Option</a></h3>
<p>OptionはScalaでもっとも多用されるデータ型の1つです。前述のとおりJavaのnullの代替として使われることが多いデータ型です。</p>
<p>Option型は簡単に言うと、値を1つだけいれることのできるコンテナです。ただし、Optionのまま様々なデータ変換処理ができるように便利な機能を持ちあわせています。</p>
<h4 id="optionの作り方と値の取得"><a name="optionの作り方と値の取得" class="plugin-anchor" href="#optionの作り方と値の取得"><i class="fa fa-link" aria-hidden="true"></i></a>Optionの作り方と値の取得</h4>
<p>では具体的にOptionの作り方と値の取得を見てみましょう。
Option型には具体的には</p>
<ul>
<li><code>Some</code></li>
<li><code>None</code></li>
</ul>
<p>以上2つの具体的な値が存在します。<code>Some</code>は何かしらの値が格納されている時の<code>Option</code>の型、
<code>None</code>は値が何も格納されていない時の<code>Option</code>の型です。</p>
<p>具体的な動きを見てみましょう。<code>Option</code>に具体的な値が入った場合は以下の様な動きをします。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> o: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Option</span>(<span class="hljs-string">"hoge"</span>)
<span class="hljs-comment">// o: Option[String] = Some(value = "hoge")</span>

o.get
<span class="hljs-comment">// res0: String = "hoge"</span>

o.isEmpty
<span class="hljs-comment">// res1: Boolean = false</span>

o.isDefined
<span class="hljs-comment">// res2: Boolean = true</span>
</code></pre>
<p>今度は<code>null</code>を<code>Option</code>に入れるとどうなるでしょうか。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> o: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Option</span>(<span class="hljs-literal">null</span>)
<span class="hljs-comment">// o: Option[String] = None</span>

o.isEmpty
<span class="hljs-comment">// res3: Boolean = true</span>

o.isDefined
<span class="hljs-comment">// res4: Boolean = false</span>
</code></pre>
<pre><code class="lang-scala">o.get
</code></pre>
<p>Optionのコンパニオンオブジェクトのapplyには引数がnullであるかどうかのチェックが入っており、引数がnullの場合、値がNoneになります。
<code>get</code>メソッドを叩いた時に、<code>java.util.NoSuchElementException</code>という例外が起こっているので、これがNPEと同じだと思うかもしれません。しかしOptionには以下の様な便利メソッドがあり、それらを回避することができます。</p>
<pre><code class="lang-scala">o.getOrElse(<span class="hljs-string">""</span>)
<span class="hljs-comment">// res5: String = ""</span>
</code></pre>
<p>以上は<code>Option[String]</code>の中身が<code>None</code>だった場合に、空文字を返すというコードになります。値以外にも処理を書くこともできます。</p>
<pre><code class="lang-scala">o.getOrElse(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">"nullは受け入れられません"</span>))
</code></pre>
<p>このように書くこともできるのです。</p>
<h4 id="optionのパターンマッチ"><a name="optionのパターンマッチ" class="plugin-anchor" href="#optionのパターンマッチ"><i class="fa fa-link" aria-hidden="true"></i></a>Optionのパターンマッチ</h4>
<p>上記では、手続き的にOptionを処理しましたが、型を持っているためパターンマッチを使って処理することもできます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> s: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Some</span>(<span class="hljs-string">"hoge"</span>)
<span class="hljs-comment">// s: Option[String] = Some(value = "hoge")</span>

<span class="hljs-keyword">val</span> result = s <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(str) =&gt; str
  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"not matched"</span>
}
<span class="hljs-comment">// result: String = "hoge"</span>
</code></pre>
<p>上記のようにSomeかNoneにパターンマッチを行い、Someにパターンマッチする場合には、その中身の値で<code>str</code>という別の変数を束縛することもできます。</p>
<p>中身を取りだすのではなく、中身で変数を束縛するというテクニックは、<code>List</code>のパターンマッチでも行うことができますが、全く同様のことがOptionでもできます。</p>
<h4 id="optionに関数を適用する"><a name="optionに関数を適用する" class="plugin-anchor" href="#optionに関数を適用する"><i class="fa fa-link" aria-hidden="true"></i></a>Optionに関数を適用する</h4>
<p>Optionには、コレクションの性質があると言いましたが、関数を内容の要素に適用できるという性質もそのまま持ち合わせています。</p>
<pre><code class="lang-scala"><span class="hljs-type">Some</span>(<span class="hljs-number">3</span>).map(_ * <span class="hljs-number">3</span>)
<span class="hljs-comment">// res6: Option[Int] = Some(value = 9)</span>
</code></pre>
<p>このように、<code>map</code>で関数を適用する事もできます。なお、値が<code>None</code>の場合にはどうなるでしょうか。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> n: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">None</span>
<span class="hljs-comment">// n: Option[Int] = None</span>

n.map(_ * <span class="hljs-number">3</span>)
<span class="hljs-comment">// res7: Option[Int] = None</span>
</code></pre>
<p>Noneのままだと型情報を持たないので一度、変数にしていますが、Noneに3をかけるという関数を適用してもNoneのままです。この性質はとても便利で、その値がOptionの中身がSomeなのかNoneなのかどちらであったとしても、同様の処理で記述でき、処理を分岐させる必要がないのです。</p>
<p>Java風に書くならば、</p>
<pre><code class="lang-scala"><span class="hljs-keyword">if</span> (n.isDefined) {
  n.get * <span class="hljs-number">3</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>
}
</code></pre>
<p>きっと上記のように書くことになっていたでしょう。ただ、よくよく考えると上記のJava風に書いた例とmapの例は異なることに気が付きます。
mapでは、値がSomeの場合は中身に関数を適用しますが、Noneの時には何も実行しません。上記の例では例外を投げています。そして、値もInt型の値を返していることも異なっています。</p>
<p>このように、Noneの場合に実行し、値を返す関数を定義できるのが<code>fold</code>です。
<code>fold</code>の宣言を<a href="https://www.scala-lang.org/api/current/scala/Option.html" target="_blank">ScalaのAPIドキュメント</a>から引用すると、</p>
<pre><code class="lang-scala">fold[<span class="hljs-type">B</span>](ifEmpty: =&gt; <span class="hljs-type">B</span>)(f: (<span class="hljs-type">A</span>) =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span>
</code></pre>
<p>となります。</p>
<p>そして関数を適用した値を最終的に取得できます。</p>
<pre><code class="lang-scala">n.fold(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>)(_ * <span class="hljs-number">3</span>)
</code></pre>
<p>上記のように書くことで、Noneの際に実行する処理を定義し、かつ、関数を適用した中身の値を取得することができます。</p>
<pre><code class="lang-scala"><span class="hljs-type">Some</span>(<span class="hljs-number">3</span>).fold(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>)(_ * <span class="hljs-number">3</span>)
<span class="hljs-comment">// res8: Int = 9</span>
</code></pre>
<p><code>Some(3)</code>を与えるとこのようにIntの9の値を返すことがわかります。</p>
<h4 id="optionの入れ子を解消する"><a name="optionの入れ子を解消する" class="plugin-anchor" href="#optionの入れ子を解消する"><i class="fa fa-link" aria-hidden="true"></i></a>Optionの入れ子を解消する</h4>
<p>実際の複雑なアプリケーションの中では、Optionの値が取得されることがよくあります。</p>
<p>たとえばキャッシュから情報を取得する場合は、キャッシュヒットする場合と、キャッシュミスする場合があり、それらはScalaではよくOption型で表現されます。</p>
<p>このようなキャッシュ取得が連続して繰り返された場合はどうなるでしょうか。例えば、1つ目と2つ目の整数の値がOptionで返ってきてそれをかけた値をもとめるような場合です。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Option[Int] = Some(value = 3)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// v2: Option[Int] = Some(value = 5)</span>

v1.map(i1 =&gt; v2.map(i2 =&gt; i1 * i2))
<span class="hljs-comment">// res9: Option[Option[Int]] = Some(value = Some(value = 15))</span>
</code></pre>
<p>mapだけを使ってシンプルに実装するとこんな風になってしまいます。ウウッ…、悲しいことに<code>Option[Option[Int]]</code>のようにOptionが入れ子になってしまいます。</p>
<p>このような入れ子のoptionを解消するために用意されているのが、<code>flatten</code>です。</p>
<pre><code class="lang-scala">v1.map(i1 =&gt; v2.map(i2 =&gt; i1 * i2)).flatten
<span class="hljs-comment">// res10: Option[Int] = Some(value = 15)</span>
</code></pre>
<p>最後に<code>flatten</code>を実行することで、Optionの入れ子を解消することができます。なお、v2がNoneである場合にも<code>flatten</code>は成立します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Option[Int] = Some(value = 3)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">None</span>
<span class="hljs-comment">// v2: Option[Int] = None</span>

v1.map(i1 =&gt; v2.map(i2 =&gt; i1 * i2)).flatten
<span class="hljs-comment">// res11: Option[Int] = None</span>
</code></pre>
<p>つまり、キャッシュミスでSomeの値が取れなかった際も問題なくこの処理で動きます。</p>
<h4 id="error_handling_ex1"><a name="error_handling_ex1" class="plugin-anchor" href="#error_handling_ex1"><i class="fa fa-link" aria-hidden="true"></i></a>練習問題 </h4>
<p><code>map</code>と<code>flatten</code>を利用して、
<code>Some(2)</code>と<code>Some(3)</code>と<code>Some(5)</code>と<code>Some(7)</code>と<code>Some(11)</code>の値をかけて、<code>Some(2310)</code>を求めてみましょう。</p>
<div><button type="button" id="answer_ex1_show_answer_button" style="display:block" onclick="document.getElementById('answer_ex1').style.display='block'; document.getElementById('answer_ex1_show_answer_button').style.display='none'; document.getElementById('answer_ex1_hide_answer_button').style.display='block'; ">解答例を表示する</button><button type="button" id="answer_ex1_hide_answer_button" style="display:none" onclick="document.getElementById('answer_ex1').style.display='none'; document.getElementById('answer_ex1_show_answer_button').style.display='block'; document.getElementById('answer_ex1_hide_answer_button').style.display='none'; ">解答例を隠す</button></div><div id="answer_ex1" style="display:none">
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> v4: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">7</span>)
<span class="hljs-keyword">val</span> v5: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">11</span>)
v1.map { i1 =&gt;
    v2.map { i2 =&gt;
        v3.map { i3 =&gt;
            v4.map { i4 =&gt;
                v5.map { i5 =&gt; i1 * i2 * i3 * i4 * i5 }
            }.flatten
        }.flatten
    }.flatten
}.flatten
</code></pre>
</div>
<h3 id="flatmap"><a name="flatmap" class="plugin-anchor" href="#flatmap"><i class="fa fa-link" aria-hidden="true"></i></a>flatMap</h3>
<p>ここまでで、<code>map</code>と<code>flatten</code>を話しましたが、実際のプログラミングではこの両方を組み合わせて使うということが多々あります。そのためその2つを適用してくれる
<code>flatMap</code>というメソッドがOptionには用意されています。名前は<code>flatMap</code>なのですが、意味としてはOptionに<code>map</code>をかけて<code>flatten</code>を適用してくれます。</p>
<p>実際に先ほどの、<code>Some(3)</code>と<code>Some(5)</code>をかける例で利用してみると以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Option[Int] = Some(value = 3)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// v2: Option[Int] = Some(value = 5)</span>

v1.flatMap(i1 =&gt; v2.map(i2 =&gt; i1 * i2))
<span class="hljs-comment">// res13: Option[Int] = Some(value = 15)</span>
</code></pre>
<p>ずいぶんシンプルに書くことができるようになります。</p>
<p><code>Some(3)</code>と<code>Some(5)</code>と<code>Some(7)</code>をかける場合はどうなるでしょうか。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Option[Int] = Some(value = 3)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// v2: Option[Int] = Some(value = 5)</span>

<span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">7</span>)
<span class="hljs-comment">// v3: Option[Int] = Some(value = 7)</span>

v1.flatMap(i1 =&gt; v2.flatMap(i2 =&gt; v3.map(i3 =&gt; i1 * i2 * i3)))
<span class="hljs-comment">// res14: Option[Int] = Some(value = 105)</span>
</code></pre>
<p>無論これは、 <code>v1</code>, <code>v2</code>, <code>v3</code> のいずれが <code>None</code> であった場合にも成立します。その場合には <code>flatten</code> の時と同様に <code>None</code> が最終的な答えになります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">None</span>
<span class="hljs-comment">// v3: Option[Int] = None</span>

v1.flatMap(i1 =&gt; v2.flatMap(i2 =&gt; v3.map(i3 =&gt; i1 * i2 * i3)))
<span class="hljs-comment">// res15: Option[Int] = None</span>
</code></pre>
<p>以上のようになります。</p>
<h4 id="error_handling_ex2"><a name="error_handling_ex2" class="plugin-anchor" href="#error_handling_ex2"><i class="fa fa-link" aria-hidden="true"></i></a>練習問題 </h4>
<p><code>flatMap</code>と<code>map</code>を利用して、
<code>Some(2)</code>と<code>Some(3)</code>と<code>Some(5)</code>と<code>Some(7)</code>と<code>Some(11)</code>の値をかけて、<code>Some(2310)</code>を求めてみましょう。</p>
<div><button type="button" id="answer_ex2_show_answer_button" style="display:block" onclick="document.getElementById('answer_ex2').style.display='block'; document.getElementById('answer_ex2_show_answer_button').style.display='none'; document.getElementById('answer_ex2_hide_answer_button').style.display='block'; ">解答例を表示する</button><button type="button" id="answer_ex2_hide_answer_button" style="display:none" onclick="document.getElementById('answer_ex2').style.display='none'; document.getElementById('answer_ex2_show_answer_button').style.display='block'; document.getElementById('answer_ex2_hide_answer_button').style.display='none'; ">解答例を隠す</button></div><div id="answer_ex2" style="display:none">
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> v4: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">7</span>)
<span class="hljs-keyword">val</span> v5: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">11</span>)
v1.flatMap { i1 =&gt;
    v2.flatMap { i2 =&gt;
        v3.flatMap { i3 =&gt;
            v4.flatMap { i4 =&gt;
                v5.map { i5 =&gt; i1 * i2 * i3 * i4 * i5 }
            }
        }
    }
}
</code></pre>
<p>一見してわかるように、かける値が増えるとネストが増えてあまり読みやすくありません。次に説明するfor式によって、より綺麗に書けるようになります。</p>
</div>
<h3 id="forを利用したflatmapのリファクタリング"><a name="forを利用したflatmapのリファクタリング" class="plugin-anchor" href="#forを利用したflatmapのリファクタリング"><i class="fa fa-link" aria-hidden="true"></i></a>forを利用したflatMapのリファクタリング</h3>
<p>Optionはコレクションのようなものだという風に言いましたが、forをOptionに使うこともできます。
for式は実際には<code>flatMap</code>と<code>map</code>展開されて実行されるのです。</p>
<p>何をいっているのかわかりにくいと思いますので、先ほどの
<code>Some(3)</code>と<code>Some(5)</code>と<code>Some(7)</code>をflatMapでかけるという処理をforで書いてみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Option[Int] = Some(value = 3)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// v2: Option[Int] = Some(value = 5)</span>

<span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">7</span>)
<span class="hljs-comment">// v3: Option[Int] = Some(value = 7)</span>

<span class="hljs-keyword">for</span> { i1 &lt;- v1
      i2 &lt;- v2
      i3 &lt;- v3 } <span class="hljs-keyword">yield</span> i1 * i2 * i3
<span class="hljs-comment">// res17: Option[Int] = Some(value = 105)</span>
</code></pre>
<p>実はこのfor式は先ほどの<code>flatMap</code>と<code>map</code>で書かれたものとまったく同じ動作をします。
<code>flatMap</code>と<code>map</code>を複数回使うような場合はfor式のほうがよりシンプルに書くことができていることがわかると思います。</p>
<h4 id="error_handling_ex3"><a name="error_handling_ex3" class="plugin-anchor" href="#error_handling_ex3"><i class="fa fa-link" aria-hidden="true"></i></a>練習問題 </h4>
<p><code>for</code>を利用して、
<code>Some(2)</code>と<code>Some(3)</code>と<code>Some(5)</code>と<code>Some(7)</code>と<code>Some(11)</code>の値をかけて、<code>Some(2310)</code>を求めてみましょう。</p>
<div><button type="button" id="answer_ex3_show_answer_button" style="display:block" onclick="document.getElementById('answer_ex3').style.display='block'; document.getElementById('answer_ex3_show_answer_button').style.display='none'; document.getElementById('answer_ex3_hide_answer_button').style.display='block'; ">解答例を表示する</button><button type="button" id="answer_ex3_hide_answer_button" style="display:none" onclick="document.getElementById('answer_ex3').style.display='none'; document.getElementById('answer_ex3_show_answer_button').style.display='block'; document.getElementById('answer_ex3_hide_answer_button').style.display='none'; ">解答例を隠す</button></div><div id="answer_ex3" style="display:none">
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> v3: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> v4: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">7</span>)
<span class="hljs-keyword">val</span> v5: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">11</span>)
<span class="hljs-keyword">for</span> { i1 &lt;- v1
      i2 &lt;- v2
      i3 &lt;- v3
      i4 &lt;- v4
      i5 &lt;- v5 } <span class="hljs-keyword">yield</span> i1 * i2 * i3 * i4 * i5
</code></pre>
</div>
<h3 id="either"><a name="either" class="plugin-anchor" href="#either"><i class="fa fa-link" aria-hidden="true"></i></a><a href="https://github.com/scala/scala/blob/v2.13.16/src/library/scala/util/Either.scala" target="_blank">Either</a></h3>
<p>Optionによりnullを使う必要はなくなりましたが、いっぽうでOptionでは処理が成功したかどうかしかわからないという問題があります。
Noneの場合、値が取得できなかったことはわかりますが、エラーの状態は取得できないので、使用できるのはエラーの種類が問題にならないような場合のみです。</p>
<p>そんなOptionと違い、エラー時にエラーの種類まで取得できるのがEitherです。
Optionが正常な値と何もない値のどちらかを表現するデータ型だったのに対して、Eitherは2つの値のどちらかを表現するデータ型です。具体的には、Optionでは<code>Some</code>と<code>None</code>の2つの値を持ちましたが、Eitherは<code>Right</code>と<code>Left</code>の2つの値を持ちます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Right</span>(<span class="hljs-number">123</span>)
<span class="hljs-comment">// v1: Either[String, Int] = Right(value = 123)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Left</span>(<span class="hljs-string">"abc"</span>)
<span class="hljs-comment">// v2: Either[String, Int] = Left(value = "abc")</span>
</code></pre>
<p>パターンマッチで値を取得できるのもOptionと同じです。</p>
<pre><code class="lang-scala">v1 <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(i) =&gt; println(i)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(s)  =&gt; println(s)
}
<span class="hljs-comment">// 123</span>
</code></pre>
<h4 id="eitherでエラー値を表現する"><a name="eitherでエラー値を表現する" class="plugin-anchor" href="#eitherでエラー値を表現する"><i class="fa fa-link" aria-hidden="true"></i></a>Eitherでエラー値を表現する</h4>
<p>一般的にEitherを使う場合、Left値をエラー値、Right値を正常な値とみなすことが多いです。英語の"right"が正しいという意味なので、それにかけているという説があります。そしてLeftに用いるエラー値ですが、これは代数的データ型（sealed traitまたはsealed abstract classとcase classで構成される一連のデータと型のこと）で定義するとよいでしょう。パターンマッチの節で解説したように代数的データ型を用いることでエラーの処理が漏れているかどうかをコンパイラが検知してくれるようになります。単に<code>Throwable</code>型をエラー型に使うのなら後述のTryで十分です。</p>
<p>例としてEitherを使ってログインのエラーを表現してみましょう。
Leftの値となる<code>LoginError</code>を定義します。
<code>sealed</code>を使って代数的データ型として定義するのがポイントです。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LoginError</span></span>
<span class="hljs-comment">// パスワードが間違っている場合のエラー</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">InvalidPassword</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginError</span></span>
<span class="hljs-comment">// nameで指定されたユーザーが見つからない場合のエラー</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserNotFound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginError</span></span>
<span class="hljs-comment">// パスワードがロックされている場合のエラー</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PasswordLocked</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LoginError</span></span>
</code></pre>
<p>ログインAPIの型は以下のようにします。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Long</span>, name: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span></span>)</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">LoginService</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span></span>(name: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">LoginError</span>, <span class="hljs-type">User</span>] = ???
}
</code></pre>
<p><code>login</code>メソッドはユーザー名とパスワードをチェックして正しい組み合わせの場合は<code>User</code>オブジェクトをEitherのRightの値で返し、エラーが起きた場合は<code>LoginError</code>をEitherのLeftの値で返します。</p>
<p>それでは、この<code>login</code>メソッドを使ってみましょう。</p>
<pre><code class="lang-scala"><span class="hljs-type">LoginService</span>.login(name = <span class="hljs-string">"dwango"</span>, password = <span class="hljs-string">"password"</span>) <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(user) =&gt; println(<span class="hljs-string">s"id: <span class="hljs-subst">${user.id}</span>"</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(<span class="hljs-type">InvalidPassword</span>) =&gt; println(<span class="hljs-string">s"Invalid Password!"</span>)
}
</code></pre>
<p>とりあえず呼び出して、<code>println</code>を使って中身を表示しているだけです。ここで注目していただきたいのが、Leftの値のパターンマッチです。
<code>InvalidPassword</code>の処理はしていますが、<code>UserNotFound</code>の場合と<code>PasswordLocked</code>の場合の処理が抜けてしまっています。そのような場合でもエラー値に代数的データ型を用いているので、コンパイラがエラー処理漏れを検知してくれます。</p>
<p>試しに上のコードをコンパイルしてみると、</p>
<pre><code class="lang-scala">&lt;console&gt;:<span class="hljs-number">11</span>: warning: <span class="hljs-keyword">match</span> may not be exhaustive.
<span class="hljs-type">It</span> would fail on the following inputs: <span class="hljs-type">Left</span>(<span class="hljs-type">PasswordLocked</span>), <span class="hljs-type">Left</span>(<span class="hljs-type">UserNotFound</span>)
              <span class="hljs-type">LoginService</span>.login(name = <span class="hljs-string">"dwango"</span>, password = <span class="hljs-string">"password"</span>) <span class="hljs-keyword">match</span> {
                                ^
</code></pre>
<p>のようにコンパイラが<code>Left(PasswordLocked)</code>と<code>Left(UserNotFound)</code>の処理が漏れていることをwarningで教えてくれます。
Eitherを使う場合はこのテクニックを覚えておいたほうがいいでしょう。</p>
<h4 id="eitherのmapとflatmap"><a name="eitherのmapとflatmap" class="plugin-anchor" href="#eitherのmapとflatmap"><i class="fa fa-link" aria-hidden="true"></i></a>EitherのmapとflatMap</h4>
<p>以上、見てきたように格納できるデータが増えているという点でEitherはOptionの拡張版に近いです。
Optionと同様にEitherもfor式を使って複数のEitherを組み合わせることができます。
EitherにはRight, Leftの2つの値がありますが、ScalaのEitherではRightが正常な値になることが多いため、mapやflatMapではRightの値が利用されます。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>ためしに<code>Either</code>の<code>map</code>メソッドを使ってみましょう</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Right</span>(<span class="hljs-number">123</span>)
<span class="hljs-comment">// v: Either[String, Int] = Right(value = 123)</span>

v.map(_ * <span class="hljs-number">2</span>)
<span class="hljs-comment">// res20: Either[String, Int] = Right(value = 246)</span>

<span class="hljs-keyword">val</span> v2: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Left</span>(<span class="hljs-string">"a"</span>)
<span class="hljs-comment">// v2: Either[String, Int] = Left(value = "a")</span>
v2.map(_ * <span class="hljs-number">2</span>) <span class="hljs-comment">// v2がLeftなので実行されない</span>
<span class="hljs-comment">// res21: Either[String, Int] = Left(value = "a")</span>
</code></pre>
<p>これでmapを使って値を二倍にする関数をRightに適用できました。
EitherがLeftの場合は何の処理もおこなわれません。これはOptionでNoneに対してmapを使った場合に何の処理もおこなわれないという動作に似ていますね。</p>
<h3 id="名前渡しパラメータ"><a name="名前渡しパラメータ" class="plugin-anchor" href="#名前渡しパラメータ"><i class="fa fa-link" aria-hidden="true"></i></a>名前渡しパラメータ</h3>
<p>少し寄り道をして、名前渡しパラメータ（by-name parameter）というScalaの機能を紹介します。これから紹介する<code>Try</code>型の実装などで使われている機能だからです。</p>
<p>Scalaにおいては、メソッド実行前にはまず引数が評価され、次いでメソッド本体のコードが実行されます。次の例からも分かります。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(x: <span class="hljs-type">Any</span>): <span class="hljs-type">Unit</span> = println(<span class="hljs-string">"f"</span>)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span></span>(): <span class="hljs-type">Unit</span> = println(<span class="hljs-string">"g"</span>)
f(g())
<span class="hljs-comment">// g</span>
<span class="hljs-comment">// f</span>
</code></pre>
<p>ごく普通の挙動だと思います。Scalaに限らず、他の多くのプログラミング言語でも同様の実行順序となります。この評価順序のことを先行評価（eager evaluation）あるいは正格評価（strict evaluation）と呼びます。</p>
<p>さて、時折この挙動を変更したい場合があります。名前渡しパラメータを使うと、
<strong>変数が実際に使用される箇所まで評価を遅延させる</strong> ことができます。メソッド本体のそれが使われる箇所で引数の式が計算されるということです。次のようなコードを見ると分かりやすいと思います。</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span></span>(): <span class="hljs-type">Unit</span> = println(<span class="hljs-string">"g"</span>)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(g: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = {
  println(<span class="hljs-string">"prologue f"</span>)
  g
  println(<span class="hljs-string">"epilogue f"</span>)
}
f(g())
<span class="hljs-comment">// prologue f</span>
<span class="hljs-comment">// g</span>
<span class="hljs-comment">// epilogue f</span>
</code></pre>
<p><code>"g"</code>の出力が関数の内側になっていることがわかると思います。メソッド<code>f</code>の引数の型に注目すると、型<code>Unit</code>の手前に<code>=&gt;</code>が付いています。これが名前渡しパラメータの指定を表します。</p>
<p>名前渡しパラメータは次のような場合に使われます。</p>
<ul>
<li>引数の式が例外を投げるかもしれないので、<code>try-finally</code>構文の中で引数を評価したい</li>
<li>引数の式がものすごく計算コストが高いかもしれないが、計算結果を本当に使うかわからない。使われる箇所で計算させたい</li>
</ul>
<p>似たような挙動は高階関数を使えば書けるのですが、名前渡しパラメータのほうが簡潔な記述ができるという点でより優れています。</p>
<h3 id="try"><a name="try" class="plugin-anchor" href="#try"><i class="fa fa-link" aria-hidden="true"></i></a><a href="https://github.com/scala/scala/blob/v2.13.16/src/library/scala/util/Try.scala" target="_blank">Try</a></h3>
<p>ScalaのTryはEitherと同じように正常な値とエラー値のどちらかを表現するデータ型です。
Eitherとの違いは、2つの型が平等ではなく、エラー値がThrowableに限定されており、型引数を1つしか取らないことです。具体的にはTryは以下の2つの値をとります。</p>
<ul>
<li>Success</li>
<li>Failure</li>
</ul>
<p>ここでSuccessは型変数を取り、任意の値を入れることができますが、FailureはThrowableしか入れることができません。そしてTryには、コンパニオンオブジェクトのapplyで生成する際に、例外をcatchし、Failureにする機能があります。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> scala.util.<span class="hljs-type">Try</span>

<span class="hljs-keyword">val</span> v: <span class="hljs-type">Try</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Try</span>(<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">"to be caught"</span>))
<span class="hljs-comment">// v: Try[Int] = Failure(exception = java.lang.RuntimeException: to be caught)</span>
</code></pre>
<p>この機能を使って、例外が起こりそうな箇所を<code>Try</code>で包み、Failureにして値として扱えるようにするのがTryの特徴です。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1 = <span class="hljs-type">Try</span>(<span class="hljs-number">3</span>)
<span class="hljs-comment">// v1: Try[Int] = Success(value = 3)</span>

<span class="hljs-keyword">val</span> v2 = <span class="hljs-type">Try</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// v2: Try[Int] = Success(value = 5)</span>

<span class="hljs-keyword">val</span> v3 = <span class="hljs-type">Try</span>(<span class="hljs-number">7</span>)
<span class="hljs-comment">// v3: Try[Int] = Success(value = 7)</span>

<span class="hljs-keyword">for</span> {
  i1 &lt;- v1
  i2 &lt;- v2
  i3 &lt;- v3
} <span class="hljs-keyword">yield</span> i1 * i2 * i3
<span class="hljs-comment">// res24: Try[Int] = Success(value = 105)</span>
</code></pre>
<h4 id="nonfatalの例外"><a name="nonfatalの例外" class="plugin-anchor" href="#nonfatalの例外"><i class="fa fa-link" aria-hidden="true"></i></a><a href="https://github.com/scala/scala/blob/v2.13.16/src/library/scala/util/control/NonFatal.scala" target="_blank"><code>NonFatal</code></a>の例外</h4>
<p><code>Try.apply</code>がcatchするのはすべての例外ではありません。
NonFatalという種類の例外だけです。
NonFatalではない例外はアプリケーション中で復旧が困難な非常に重度なものです。なので、NonFatalではない例外はcatchせずにアプリケーションを終了させて、外部から再起動などをしたほうがいいです。</p>
<p>Try以外でも、たとえば扱うことができる全ての例外をまとめて処理したい場合などに、</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span>

<span class="hljs-keyword">try</span> {
  ???
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt; <span class="hljs-comment">// 例外の処理</span>
}
</code></pre>
<p>というパターンが実践的なコード中に出てくることがしばしばあるので覚えておくとよいと思います。</p>
<h3 id="optionとeitherとtryの使い分け"><a name="optionとeitherとtryの使い分け" class="plugin-anchor" href="#optionとeitherとtryの使い分け"><i class="fa fa-link" aria-hidden="true"></i></a>OptionとEitherとTryの使い分け</h3>
<p>ではエラー処理においてOptionとEitherとTryはどのように使い分けるべきなのでしょうか。</p>
<p>まず基本的にJavaでnullを使うような場面はOptionを使うのがよいでしょう。コレクションの中に存在しなかったり、ストレージ中から条件に合うものを発見できなかったりした場合はOptionで十分だと考えられます。</p>
<p>次にEitherですが、Optionを使うのでは情報が不足しており、かつ、エラー状態が代数的データ型としてちゃんと定められるものに使うのがよいでしょう。
Javaでチェック例外を使っていたようなところで使う、つまり、復帰可能なエラーだけに使うという考え方でもよいです。
Eitherと例外を併用するのもアリだと思います。</p>
<p>TryはJavaの例外をどうしても値として扱いたい場合に用いるとよいです。非同期プログラミングで使ったり、実行結果を保存しておき、あとで中身を参照したい場合などに使うことも考えられます。</p>
<h2 id="optionの例外処理をeitherでリファクタする実例"><a name="optionの例外処理をeitherでリファクタする実例" class="plugin-anchor" href="#optionの例外処理をeitherでリファクタする実例"><i class="fa fa-link" aria-hidden="true"></i></a>Optionの例外処理をEitherでリファクタする実例</h2>
<p>Scalaでリレーショナルデータベースを扱う場合、関連をたどっていく中でどのタイミングで情報が取得できなかったのかを返さねばならないことがあります。</p>
<p>Noneを盲目的に処理するのであれば、flatMapやfor式をつかえば畳み込んでスッキリかけるのですが、関連を取得していくなかでどのタイミングでNoneが取得されてしまったのか返したい場合にはそうは行かず、結局match caseの深いネストになってしまいます。</p>
<p>例を挙げます。</p>
<p>ユーザーとアドレスがそれぞれデータベースに格納されており、ユーザーIDを利用してそのユーザーを検索し、ユーザーが持つアドレスIDでアドレスを検索し、さらにその郵便番号を取得するような場合を考えます。</p>
<p>失敗結果としては</p>
<ul>
<li>ユーザーがみつからない</li>
<li>ユーザーがアドレスを持っていない</li>
<li>アドレスがみつからない</li>
<li>アドレスが郵便番号を持っていない</li>
</ul>
<p>という4つの失敗パターンがあり、それらを結果オブジェクトとして返さなくてはなりません。</p>
<p>以下のようなコードになります。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MainBefore</span> </span>{

  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, postalCode: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>]</span>)</span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, addressId: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]</span>)</span>

  <span class="hljs-keyword">val</span> userDatabase: <span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">User</span>] = <span class="hljs-type">Map</span> (
    <span class="hljs-number">1</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"太郎"</span>, <span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)),
    <span class="hljs-number">2</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"二郎"</span>, <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)),
    <span class="hljs-number">3</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"プー太郎"</span>, <span class="hljs-type">None</span>)
  )

  <span class="hljs-keyword">val</span> addressDatabase: <span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Address</span>] = <span class="hljs-type">Map</span> (
    <span class="hljs-number">1</span> -&gt; <span class="hljs-type">Address</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"渋谷"</span>, <span class="hljs-type">Some</span>(<span class="hljs-string">"150-0002"</span>)),
    <span class="hljs-number">2</span> -&gt; <span class="hljs-type">Address</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"国際宇宙ステーション"</span>, <span class="hljs-type">None</span>)
  )

  <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span>(<span class="hljs-params">postalCode: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserNotFound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserNotHasAddress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AddressNotFound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AddressNotHasPostalCode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>

  <span class="hljs-comment">// どこでNoneが生じたか取得しようとするとfor式がつかえず地獄のようなネストになる</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPostalCodeResult</span></span>(userId: <span class="hljs-type">Int</span>): <span class="hljs-type">PostalCodeResult</span> = {
    findUser(userId) <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(user) =&gt;
        user.addressId <span class="hljs-keyword">match</span> {
          <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(addressId) =&gt;
            findAddress(addressId) <span class="hljs-keyword">match</span> {
              <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(address) =&gt;
                address.postalCode <span class="hljs-keyword">match</span> {
                  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(postalCode) =&gt; <span class="hljs-type">Success</span>(postalCode)
                  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">AddressNotHasPostalCode</span>
                }
              <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">AddressNotFound</span>
            }
          <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">UserNotHasAddress</span>
        }
      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-type">UserNotFound</span>
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUser</span></span>(userId: <span class="hljs-type">Int</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">User</span>] = {
    userDatabase.get(userId)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findAddress</span></span>(addressId: <span class="hljs-type">Int</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Address</span>] = {
    addressDatabase.get(addressId)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = {
    println(getPostalCodeResult(<span class="hljs-number">1</span>)) <span class="hljs-comment">// Success(150-0002)</span>
    println(getPostalCodeResult(<span class="hljs-number">2</span>)) <span class="hljs-comment">// AddressNotHasPostalCode</span>
    println(getPostalCodeResult(<span class="hljs-number">3</span>)) <span class="hljs-comment">// UserNotHasAddress</span>
    println(getPostalCodeResult(<span class="hljs-number">4</span>)) <span class="hljs-comment">// UserNotFound</span>
  }
}
</code></pre>
<p>getPostalCodeResultが鬼のようなmatch caseのネストになっていることがわかります。このような可読性の低いコードを、Eitherを使って書きなおすことができます。</p>
<p>以下のように全てのfindメソッドをEitherでFailureをLeftに、正常取得できた場合の値の型をRightにして書き直します。</p>
<p>findの各段階でFailureオブジェクトに引き換えるという動きをさせるわけです。</p>
<p>リファクタリングした結果は以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MainRefactored</span> </span>{

  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, postalCode: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>]</span>)</span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, addressId: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]</span>)</span>

  <span class="hljs-keyword">val</span> userDatabase: <span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">User</span>] = <span class="hljs-type">Map</span> (
    <span class="hljs-number">1</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"太郎"</span>, <span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)),
    <span class="hljs-number">2</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"二郎"</span>, <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)),
    <span class="hljs-number">3</span> -&gt; <span class="hljs-type">User</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"プー太郎"</span>, <span class="hljs-type">None</span>)
  )

  <span class="hljs-keyword">val</span> addressDatabase: <span class="hljs-type">Map</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Address</span>] = <span class="hljs-type">Map</span> (
    <span class="hljs-number">1</span> -&gt; <span class="hljs-type">Address</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"渋谷"</span>, <span class="hljs-type">Some</span>(<span class="hljs-string">"150-0002"</span>)),
    <span class="hljs-number">2</span> -&gt; <span class="hljs-type">Address</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"国際宇宙ステーション"</span>, <span class="hljs-type">None</span>)
  )

  <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span>(<span class="hljs-params">postalCode: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PostalCodeResult</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserNotFound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UserNotHasAddress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AddressNotFound</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AddressNotHasPostalCode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Failure</span></span>

  <span class="hljs-comment">// 本質的に何をしているかわかりやすくリファクタリング</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPostalCodeResult</span></span>(userId: <span class="hljs-type">Int</span>): <span class="hljs-type">PostalCodeResult</span> = {
    (<span class="hljs-keyword">for</span> {
      user &lt;- findUser(userId)
      address &lt;- findAddress(user)
      postalCode &lt;- findPostalCode(address)
    } <span class="hljs-keyword">yield</span> <span class="hljs-type">Success</span>(postalCode)).merge
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findUser</span></span>(userId: <span class="hljs-type">Int</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">Failure</span>, <span class="hljs-type">User</span>] = {
    userDatabase.get(userId).toRight(<span class="hljs-type">UserNotFound</span>)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findAddress</span></span>(user: <span class="hljs-type">User</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">Failure</span>, <span class="hljs-type">Address</span>] = {
    <span class="hljs-keyword">for</span> {
      addressId &lt;- user.addressId.toRight(<span class="hljs-type">UserNotHasAddress</span>)
      address &lt;- addressDatabase.get(addressId).toRight(<span class="hljs-type">AddressNotFound</span>)
    } <span class="hljs-keyword">yield</span> address
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findPostalCode</span></span>(address: <span class="hljs-type">Address</span>): <span class="hljs-type">Either</span>[<span class="hljs-type">Failure</span>, <span class="hljs-type">String</span>] = {
    address.postalCode.toRight(<span class="hljs-type">AddressNotHasPostalCode</span>)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = {
    println(getPostalCodeResult(<span class="hljs-number">1</span>)) <span class="hljs-comment">// Success(150-0002)</span>
    println(getPostalCodeResult(<span class="hljs-number">2</span>)) <span class="hljs-comment">// AddressNotHasPostalCode</span>
    println(getPostalCodeResult(<span class="hljs-number">3</span>)) <span class="hljs-comment">// UserNotHasAddress</span>
    println(getPostalCodeResult(<span class="hljs-number">4</span>)) <span class="hljs-comment">// UserNotFound</span>
  }
}
</code></pre>
<p>以上のようになり、</p>
<pre><code class="lang-scala">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPostalCodeResult</span></span>(userId: <span class="hljs-type">Int</span>): <span class="hljs-type">PostalCodeResult</span> = {
    (<span class="hljs-keyword">for</span> {
      user &lt;- findUser(userId)
      address &lt;- findAddress(user)
      postalCode &lt;- findPostalCode(address)
    } <span class="hljs-keyword">yield</span> <span class="hljs-type">Success</span>(postalCode)).merge
  }
</code></pre>
<p>getPostalCodeResultが本質的に何をしているのかが非常にわかりやすいコードとなりました。何をしているかというと、
for式で値を取得した後、mergeメソッドにより中身を畳み込んで取得しています。</p>
<blockquote id="fn_1">
<sup>1</sup>. Scala 2.11までは、両者の値を平等に扱っていたため <code>.right</code> や <code>.left</code> を用いてどちらの値をmapに渡すかを明示する必要がありました。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>
</body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="case-class-and-pattern-matching.html" class="navigation navigation-prev " aria-label="Previous page: ケースクラスとパターンマッチング">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="implicit.html" class="navigation navigation-next " aria-label="Next page: Implicit">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"エラー処理","level":"1.16","depth":1,"next":{"title":"Implicit","level":"1.17","depth":1,"path":"implicit.md","ref":"implicit.md","articles":[]},"previous":{"title":"ケースクラスとパターンマッチング","level":"1.15","depth":1,"path":"case-class-and-pattern-matching.md","ref":"case-class-and-pattern-matching.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-codeblock","japanese-support","footnote-string-to-number","anchors","regexplace","forkmegithub"],"root":"./honkit","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"regexplace":{"substitutes":[{"pattern":"<!-- begin answer id=\"(.*)\" style=\"(.*)\" -->","flags":"g","substitute":"<div><button type=\"button\" id=\"$1_show_answer_button\" style=\"display:block\" onclick=\"document.getElementById('$1').style.display='block'; document.getElementById('$1_show_answer_button').style.display='none'; document.getElementById('$1_hide_answer_button').style.display='block'; \">解答例を表示する</button><button type=\"button\" id=\"$1_hide_answer_button\" style=\"display:none\" onclick=\"document.getElementById('$1').style.display='none'; document.getElementById('$1_show_answer_button').style.display='block'; document.getElementById('$1_hide_answer_button').style.display='none'; \">解答例を隠す</button></div><div id=\"$1\" style=\"$2\">"},{"pattern":"<!-- end answer -->","flags":"g","substitute":"</div>"}]},"search":{},"footnote-string-to-number":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"japanese-support":{},"highlight":{},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"default","theme":"chrome","unindent":false},"forkmegithub":{"color":"darkblue","url":"https://github.com/scala-text/scala_text"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"INTRODUCTION.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala研修テキスト","gitbook":"*"},"file":{"path":"error-handling.md","mtime":"2025-08-02T03:34:38.703Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-08-02T03:34:45.166Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-forkmegithub/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

