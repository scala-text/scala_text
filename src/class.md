# クラス

これからクラスとは何かということに関して説明してます。最低限、Javaのクラスがわかっている事を前提にしますが、ご了承ください。

## クラス定義（★★★）

Scalaにおけるクラスは、記法を除けばJava言語のクラスと大して変わりません。Scalaのクラス定義はおおまかには次のような形を取ります。

```scala
class クラス名(コンストラクタ引数1 :コンストラクタ引数1の型, コンストラクタ引数2 :コンストラクタ引数2の型, ...) {
  0個以上のフィールドの定義またはメソッド定義
}
```

たとえば、点を表すクラス`Point`を定義したいとします。`Point`はx座標を表すフィールド`x`（`Int`型）とフィールド`y`（`Int`型）からなるとします。このクラス`Point`をScalaで書くと次のようになります。

```tut:silent
class Point(_x: Int, _y: Int) {
  val x = _x
  val y = _y
}
```

コンストラクタの引数をそのまま公開したい場合は、以下のように短く書くこともできます。

```tut:silent
class Point(val x: Int, val y: Int)
```

* クラス名の直後にコンストラクタの定義がある
* val/varによって、コンストラクタ引数をフィールドとして公開することができる

点に注目してください。まず、最初の点ですが、Scalaでは1クラスに付き、基本的には1つのコンストラクタしか
使いません。文法上は複数のコンストラクタを定義できるようになっていますが、実際に使うことはまずないので
覚える必要はないでしょう。一応、Scalaでは複数のコンストラクタが定義できるので、この最初の1つのコンストラクタ
を*プライマリコンストラクタ*として特別に扱っています。

プライマリコンストラクタの引数にval/varをつけるとそのフィールドは公開され、外部からアクセスできるように
なります。なお、コンストラクタ引数のスコープはクラス定義全体におよびます。そのため、

```tut:silent
class Point(val x: Int, val y: Int) {
  def +(p: Point): Point = {
    new Point(x + p.x, y + p.y)
  }
  override def toString(): String = "(" + x + ", " + y + ")"
}
```

のように、メソッド定義の中から直接コンストラクタ引数を参照できます。

## メソッド定義（★★★）

先ほど既にメソッド定義の例として`+`メソッドの定義が出てきましたが、一般的には、

```scala
(private[this]/protected[package名]) def メソッド名(引数名1: 引数1の型, 引数名2: 引数2の型, ...): 返り値の型 = {
  本体のコード
}
```

という形をとります。ちなみに、メソッド本体が1つの式だけからなる場合は、

```scala
(private[this]/protected[package名]) def メソッド名(引数名1: 引数1の型, 引数名2: 引数2の型, ...): 返り値の型 = 本体のコード
```

と書けます（実際には、こちらの方が基本形で、`= {}`を使ったスタイルの方が`{}`内に複数の式を並べて書けることを利用
した派生形になりますが、前者のパターンを使うことが多いでしょう）。

返り値の型は省略しても特別な場合以外型推論してくれますが、読みやすさのために、返り値の型は明記する習慣を付けるようにしましょう。また、`private`を付けるとそのクラス内だけから、`protected`を付けるとそのクラスの派生クラスからのみアクセスできるフィールドになります。さらに、 `private[this]` をつけると、同じオブジェクトからのみ、 `protected[パッケージ名]` をつけると、追加で同じパッケージに所属しているもの全てからアクセスできるようになります。`private`も`protected`も付けない場合、そのフィールドはpublicとみなされます。

先ほど定義した`Point`クラスをREPLから使ってみましょう。

```tut
class Point(val x: Int, val y: Int) {
  def +(p: Point): Point = {
    new Point(x + p.x, y + p.y)
  }
  override def toString(): String = "(" + x + ", " + y + ")"
}

val p1 = new Point(1, 1)

val p2 = new Point(2, 2)

p1 + p2
```

### メソッドのカリー化（★★★）

メソッドは複数の引数リストを持つことができます。メソッドが

```scala
def メソッド名(引数名1: 型名1, 引数名2: 型名2, ...)(引数名N: 型名N, ..., 引数M: N): 返り値型 = 本体
```

のように複数の引数リストを持つように定義したとき、メソッド定義はカリー化されていると
言います。カリー化は普通の関数型言語では重要なテクニックですが、Scalaでのカリー化は意味合いがいささかことなります。
後述するimplicit parameterなどを使う場合、複数の引数リストを作らなければならないためカリー化が必要になるのです。
何はともあれ、カリー化された加算メソッドを定義してみましょう。

```tut
class Adder {
  def add(x: Int)(y: Int): Int = x + y
}

val adder = new Adder()

adder.add(2)(3)

adder.add(2) _
```

カリー化されたメソッドは`obj.m(x, y)`の形式でなく`obj.m(x)(y)`の形式で呼びだすことになります。また、一番下の例のように
最初の引数だけを適用して新しい関数を作る（部分適用）こともできます。

## フィールド定義（★★★）

フィールド定義は

```scala
(private/protected) (val/var) フィールド名: フィールドの型 = フィールドに代入される値の式
```

という形を取ります。`val`の場合は変更不能、`var`の場合は変更可能なフィールドになります。また、`private`を付けるとその
クラス内だけから、`protected`を付けるとそのクラスの派生クラスからのみアクセスできるフィールドになります。`private`
も`protected`も付けない場合、そのフィールドはpublicとみなされます。

## 継承（★★★）

クラスのもう1つの機能は、継承です。
継承には2つの目的があります。
1つは継承によりスーパークラスの実装をサブクラスでも使うことで実装を再利用することです。
もう1つは複数のサブクラスが共通のスーパークラスのインタフェースを継承することで処理を共通化することです[^subtyping_polymorphism]。

実装の継承には複数の継承によりメソッドやフィールドの名前が衝突する場合の振舞いなどに問題があることが知られており、Javaでは実装継承が1つだけに限定されています。
Java 8ではインタフェースにデフォルトの実装を持たせられるようになりましたが、変数は持たせられないなどの制約があります。
Scalaではトレイトという仕組みで複数の実装の継承を実現していますが、トレイトについては別の節で説明します。

ここでは通常のScalaのクラスの継承について説明します。
Scalaでのクラスの継承は次のような構文になります。

```scala
class (....) extends 継承元クラス {
  ....
}
```

基本的に、継承のはたらきはJavaのクラスと同じですが、既存のメソッドをオーバーライドするときは`override`キーワードを
使わなければならない点が異なります。たとえば、

```tut
class APrinter() {
  def print(): Unit = {
    println("A")
  }
}

class BPrinter() extends APrinter {
  override def print(): Unit = {
    println("B")
  }
}

new APrinter().print

new BPrinter().print
```

のようにすることができます。ここで`override`キーワードをはずすと、

```tut:fail
class BPrinter() extends APrinter {
  def print(): Unit = {
    println("B")
  }
}
```

のようにメッセージを出力して、**コンパイルエラー**になります。Javaではしばしば、気付かずに既存のメソッドを
オーバーライドするつもりで新しいメソッドを定義してしまうというミスがありましたが、Scalaでは`override`キーワードを使って言語レベルでこの問題に対処しているのです。

[^subtyping_polymorphism]: このように継承などにより型に親子関係を作り、複数の型に共通のインタフェースを持たせることをサブタイピング・ポリモーフィズムと呼びます。Scalaでは他にも構造的部分型というサブタイピング・ポリモーフィズムの機能がありますが、実際に使われることが少ないため、このテキストでは説明を省略しています。
