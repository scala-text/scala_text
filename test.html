
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>テスト · Scala研修テキスト</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-forkmegithub/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="java-interop.html" />
    
    
    <link rel="prev" href="future-and-promise.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="introduction-to-scala.html">
            
                <a href="introduction-to-scala.html">
            
                    
                    Scalaとは
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="sbt-install.html">
            
                <a href="sbt-install.html">
            
                    
                    sbtをインストールする
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="basic.html">
            
                <a href="basic.html">
            
                    
                    Scalaの基本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="sbt-compile-execute.html">
            
                <a href="sbt-compile-execute.html">
            
                    
                    sbtでプログラムをコンパイル・実行する
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="IDE.html">
            
                <a href="IDE.html">
            
                    
                    IDE(IntelliJ IDEA)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="notation.html">
            
                <a href="notation.html">
            
                    
                    記法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="control-syntax.html">
            
                <a href="control-syntax.html">
            
                    
                    Scalaの制御構文
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="class.html">
            
                <a href="class.html">
            
                    
                    クラス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="object.html">
            
                <a href="object.html">
            
                    
                    オブジェクト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="trait.html">
            
                <a href="trait.html">
            
                    
                    トレイト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="type-parameter.html">
            
                <a href="type-parameter.html">
            
                    
                    型パラメータと変位指定
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="function.html">
            
                <a href="function.html">
            
                    
                    関数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="collection.html">
            
                <a href="collection.html">
            
                    
                    コレクションライブラリ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="case-class-and-pattern-matching.html">
            
                <a href="case-class-and-pattern-matching.html">
            
                    
                    ケースクラスとパターンマッチング
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="error-handling.html">
            
                <a href="error-handling.html">
            
                    
                    エラー処理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="implicit.html">
            
                <a href="implicit.html">
            
                    
                    Implicit
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="introduction-to-typeclass.html">
            
                <a href="introduction-to-typeclass.html">
            
                    
                    型クラスへの誘い
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="future-and-promise.html">
            
                <a href="future-and-promise.html">
            
                    
                    FutureとPromise
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.20" data-path="test.html">
            
                <a href="test.html">
            
                    
                    テスト
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="java-interop.html">
            
                <a href="java-interop.html">
            
                    
                    Javaとの相互運用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="exercises.html">
            
                <a href="exercises.html">
            
                    
                    S99の案内
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="advanced-trait-di.html">
            
                <a href="advanced-trait-di.html">
            
                    
                    トレイトの応用編：依存性の注入によるリファクタリング
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="typeclass.html">
            
                <a href="typeclass.html">
            
                    
                    付録：様々な型クラスの紹介
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >テスト</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><h1 id="テスト"><a name="テスト" class="plugin-anchor" href="#テスト"><i class="fa fa-link" aria-hidden="true"></i></a>テスト</h1>
<p>ソフトウェアをテストすることは多くの開発者が必要なことだと認識していますが、テストという言葉の定義は各人で異なり話が噛み合わない、という状況が多々発生します。このような状況に陥る原因の多くは人や組織、開発するソフトウェアによってコンテキストが異なるにもかかわらず、言葉の定義について合意形成せずに話し始めるためです。</p>
<p>言葉に食い違いがある状態で会話をしても不幸にしかなりません。世の開発者全員で合意することは不可能かもしれませんが、プロジェクト内ではソフトウェアテストという言葉の定義について合意を形成しましょう。また、新しくプロジェクトに配属された場合は定義を確認しておきましょう。</p>
<p>本章では、ソフトウェアテストを下記の定義とします。この定義は古典と呼ばれている書籍『<a href="https://www.amazon.co.jp/dp/4764903296" target="_blank">ソフトウェアテストの技法　第二版</a>』をベースにしたものです。</p>
<blockquote>
<p>ソフトウェアテストとは、ソフトウェアが意図されたように動作し意図されないことは全て実行されないように設計されていることを検証するように設計されたプロセス、あるいは一連のプロセスである。</p>
</blockquote>
<p>限られたリソースの中でうまくバグを発見できるテストを設計するためには、プロジェクトの仕様、採用した技術、開発の目的を理解する必要があります。こういった知識を得てこそ何を、なぜ、どのように検証するか考えられるようになります。そうして考えられた計画を用いて対象のソフトウェアを検証することが、テストという行為なのです。</p>
<h2 id="テストの分類"><a name="テストの分類" class="plugin-anchor" href="#テストの分類"><i class="fa fa-link" aria-hidden="true"></i></a>テストの分類</h2>
<p>テストは幾つかのグループに分類できますが、分類方法についても書籍、組織、チームによってその定義は様々です。プロジェクトに携わる際は、どういった定義でテストを分類しているか確認しておきましょう。参考までに、いくつかの分類例を示します。</p>
<ul>
<li><a href="https://www.shoeisha.co.jp/book/detail/9784798124582" target="_blank">実践テスト駆動開発</a>での定義<ul>
<li>ユニットテスト<ul>
<li>オブジェクトは正しく振る舞っているか、またオブジェクトが扱いやすいかどうかをテストします。</li>
</ul>
</li>
<li>インテグレーションテスト<ul>
<li>変更できないコードに対して、書いたコードが機能するかテストします。</li>
</ul>
</li>
<li>受け入れテスト<ul>
<li>システム全体が機能するかテストします。</li>
</ul>
</li>
</ul>
</li>
<li>JSTQB　ソフトウェアテスト標準用語集<sup><a href="#fn_1" id="reffn_1">1</a></sup>での定義<ul>
<li>コンポーネントテスト（component testing）<ul>
<li><code>ユニットテスト</code>とも呼びます。</li>
<li>個々のソフトウェアコンポーネントのテストを指します。</li>
<li>独立してテストできるソフトウェアの最小単位をコンポーネントと呼びます。</li>
</ul>
</li>
<li>統合テスト<ul>
<li>統合したコンポーネントやシステムのインタフェースや相互作用の欠陥を摘出するためのテストです。</li>
</ul>
</li>
<li>システムテスト<ul>
<li>統合されたシステムが、特定の要件を満たすことを実証するためのテストのプロセスです。</li>
</ul>
</li>
<li>受け入れテスト<ul>
<li>システムがユーザのニーズ、要件、ビジネスプロセスを満足するかをチェックするためのテストです。</li>
<li>このテストによって、システムが受け入れ基準を満たしているか判定したり、ユーザや顧客がシステムを受け入れるかどうかを判定できます。</li>
</ul>
</li>
</ul>
</li>
<li>本テキストの初期執筆時に書かれていた定義<ul>
<li>ユニットテスト（Unit Test）<ul>
<li><code>単体テスト</code>とも呼びます。</li>
<li>プログラム全体ではなく小さな単位（例えば関数ごと）に実行されます。このテストの目的はその単体が正しく動作していることを確認することです。ユニットテスト用のフレームワークの種類はとても多くJavaのJUnitやPHPのPHPUnitなどxUnitと呼ばれることが多いです。</li>
</ul>
</li>
<li>結合テスト・統合テスト (Integration Test)<ul>
<li>プログラム全体が完成してから実際に動作するかを検証するために実行します。人力で行う（例えば機能を開発した本人）ものやSeleniumなどを使って自動で実行するものがあります。</li>
</ul>
</li>
<li>システムテスト・品質保証テスト (System Test)<ul>
<li>実際に利用される例に則した様々な操作を行い問題ないかを確認します。ウェブアプリケーションの場合ですと、例えばフォームに入力する値の境界値を超えた場合、超えない場合のレスポンスの検証を行ったり様々なウェブブラウザで正常に動作するかなどを確認します。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>共通しているのは、分類ごとにテストの目的や粒度が異なること、どのような分類にせよ数多くのテストを通過する必要があることです。</p>
<h2 id="ユニットテスト"><a name="ユニットテスト" class="plugin-anchor" href="#ユニットテスト"><i class="fa fa-link" aria-hidden="true"></i></a>ユニットテスト</h2>
<p>ここでは、ユニットテストを<code>小さな単位で自動実行できるテスト</code>と定義して、ユニットテストにフォーカスして解説を行います。ユニットテストはScalaでのプログラミングにも密接に関わってくるためです。</p>
<p>ユニットテストを行う理由は大きく3つあげられます。</p>
<ol>
<li>実装の前に満たすべき仕様をユニットテストとして定義し、実装を行うことで要件漏れのない機能を実装することができる</li>
<li>ユニットテストによって満たすべき仕様がテストされた状態ならば、安心してリファクタリングすることができる</li>
<li>全ての機能を実装する前に、単体でテストをすることができる</li>
</ol>
<p>最初の理由であるテストコードをプロダクトコードよりも先に書くことをテストファーストと呼びます。そして、失敗するテストを書きながら実装を進めていく手法のことをテスト駆動開発（TDD: Test Driven Development）といいます。なお、TDDについてはそれ単独で章になり得るので本節では解説しません。</p>
<p>リファクタリングについては、次節で詳しく触れます。</p>
<p>ユニットテストを実装するにあたって、気をつけておきたいことが二点あります。</p>
<ol>
<li>高速に実行できるテストを実装する</li>
<li>再現性のあるテストを実装する</li>
</ol>
<p>高速に実行できることでストレスなくユニットテストを実行できるようになります。また、再現性を確保することでバグの原因特定を容易にできます。</p>
<h2 id="リファクタリング"><a name="リファクタリング" class="plugin-anchor" href="#リファクタリング"><i class="fa fa-link" aria-hidden="true"></i></a>リファクタリング</h2>
<p>リファクタリングとは、ソフトウェアの仕様を変えること無く、プログラムの構造を扱いやすく変化させることです。</p>
<p>マーチン・ファウラーの<a href="https://www.amazon.co.jp/dp/427405019X" target="_blank">リファクタリング</a>では、リファクタリングを行う理由として4つの理由が挙げられています。</p>
<ol>
<li>ソフトウェア設計を向上させるため</li>
<li>ソフトウェアを理解しやすくするため</li>
<li>バグを見つけやすくするため</li>
<li>早くプログラミングできるようにするため</li>
</ol>
<p>また同書の中でTDDの提唱者であるケント・ベックは、以下に示す経験則から、リファクタリングは有効であると述べています。</p>
<ol>
<li>読みにくいプログラムは変更しにくい</li>
<li>ロジックが重複しているプログラムは変更しにくい</li>
<li>機能追加に伴い、既存のコード修正が必要になるプログラムは変更しにくい</li>
<li>複雑な条件分岐の多いプログラムは変更しにくい</li>
</ol>
<p>リファクタリングは中長期的な開発の効率をあげるための良い手段であり、変更が要求されるソフトウェアでは切っても切ることができないプラクティスです。そしてリファクタリングを行う際に、ソフトウェアの仕様を変えなかったことを確認する手段としてユニットテストが必要になるのです。</p>
<h2 id="テスティングフレームワーク"><a name="テスティングフレームワーク" class="plugin-anchor" href="#テスティングフレームワーク"><i class="fa fa-link" aria-hidden="true"></i></a>テスティングフレームワーク</h2>
<p>実際にユニットテストのテストコードを書く際には、テスティングフレームワークを利用します。
Scalaで広く利用されているテスティングフレームワークとして紹介されるのは以下の2つです。</p>
<ul>
<li><a href="https://etorreborre.github.io/specs2/" target="_blank">Specs2</a></li>
<li><a href="https://www.scalatest.org/" target="_blank">ScalaTest</a></li>
</ul>
<p>今回は、マクロを用いて実装されているpower assertという便利な機能を使いたいため、ScalaTestを利用します<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p>
<p>ScalaTestは、テスティングフレームワークの中でも振舞駆動開発（BDD :Behavior Driven Development）をサポートしているフレームワークです。
BDDでは、テスト内にそのプログラムに与えられた機能的な外部仕様を記述させることで、テストが本質的に何をテストしようとしているのかをわかりやすくする手法となります。基本この書き方に沿って書いていきます。</p>
<h2 id="テストができるsbtプロジェクトの作成"><a name="テストができるsbtプロジェクトの作成" class="plugin-anchor" href="#テストができるsbtプロジェクトの作成"><i class="fa fa-link" aria-hidden="true"></i></a>テストができるsbtプロジェクトの作成</h2>
<p>では、実際にユニットテストを書いてみましょう。まずはプロジェクトを作成します。</p>
<p>適当な作業フォルダにて以下を実行します。ここでは、<code>scalatest_study</code>を作り、さらに中に<code>src/main/scala</code>と<code>src/test/scala</code>の2つのフォルダを作りましょう。</p>
<p><code>build.sbt</code>を用意して、以下を記述しておきます。</p>
<pre><code class="lang-scala">name := <span class="hljs-string">&quot;scalatest_study&quot;</span>

version := <span class="hljs-string">&quot;1.0&quot;</span>

scalaVersion := <span class="hljs-string">&quot;2.13.14&quot;</span>

libraryDependencies ++= <span class="hljs-type">Seq</span>(
  <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest-flatspec&quot;</span> % <span class="hljs-string">&quot;3.2.19&quot;</span> % <span class="hljs-string">&quot;test&quot;</span>,
  <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest-diagrams&quot;</span> % <span class="hljs-string">&quot;3.2.19&quot;</span> % <span class="hljs-string">&quot;test&quot;</span>,
)
</code></pre>
<p>その後、<code>scalatest_study</code>フォルダ内で、<code>sbt compile</code>を実行してみましょう。</p>
<pre><code>[info] Set current project to scalatest_study (in build file:/Users/dwango/workspace/scalatest_study/scalatest_study/)
[info] Updating {file:/Users/dwango/workspace/scalatest_study/scalatest_study/}scalatest_study...
[info] Resolving jline#jline;2.12.1 ...
[info] downloading https://repo1.maven.org/maven2/org/scalatest/scalatest-flatspec_2.13/3.2.17/scalatest-flatspec_2.13-3.2.17.jar ...
[info]     [SUCCESSFUL ] org.scalatest#scalatest-flatspec_2.13;3.2.17!scalatest-flatspec_2.13.jar(bundle) (5456ms)
[info] downloading https://repo1.maven.org/maven2/org/scalatest/scalatest-diagrams_2.13/3.2.17/scalatest-diagrams_2.13-3.2.17.jar ...
[info]     [SUCCESSFUL ] org.scalatest#scalatest-diagrams_2.13;3.2.17!scalatest-diagrams_2.13.jar(bundle) (5199ms)
[info] Done updating.
[success] Total time: 11 s, completed 2023/02/09 16:48:42
</code></pre><p>以上のように表示されれば、これで準備は完了です。</p>
<h2 id="calcクラスとそのテストを実際に作る"><a name="calcクラスとそのテストを実際に作る" class="plugin-anchor" href="#calcクラスとそのテストを実際に作る"><i class="fa fa-link" aria-hidden="true"></i></a>Calcクラスとそのテストを実際に作る</h2>
<p>それでは、具体的なテストを実装してみましょう。下記の仕様を満たすCalcクラスを作成し、それらをテストしていきます。</p>
<ul>
<li>整数の配列を取得し、それらを足し合わせた整数を返すことができるsum関数を持つ</li>
<li>整数を2つ受け取り、分子を分母で割った浮動小数点の値を返すことができるdiv関数を持つ</li>
<li>整数値を1つ受け取り、その値が素数であるかどうかのブール値を返すisPrime関数を持つ</li>
</ul>
<p>これを実装した場合、<code>src/main/scala/Calc.scala</code>は以下のようになります。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calc</span> </span>{

  <span class="hljs-comment">/** 整数の配列を取得し、それらを足し合わせた整数を返す
    *
    * Intの最大を上回った際にはオーバーフローする
    */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(seq: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">Int</span> = seq.foldLeft(<span class="hljs-number">0</span>)(_ + _)

  <span class="hljs-comment">/** 整数を2つ受け取り、分子を分母で割った浮動小数点の値を返す
    *
    * 0で割ろうとした際には実行時例外が投げられる
    */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div</span></span>(numerator: <span class="hljs-type">Int</span>, denominator: <span class="hljs-type">Int</span>): <span class="hljs-type">Double</span> = {
    <span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ArithmeticException</span>(<span class="hljs-string">&quot;/ by zero&quot;</span>)
    numerator.toDouble / denominator.toDouble
  }

  <span class="hljs-comment">/** 整数値を一つ受け取り、その値が素数であるかどうかのブール値を返す */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPrime</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Boolean</span> = {
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-literal">false</span> <span class="hljs-keyword">else</span> !((<span class="hljs-number">2</span> to <span class="hljs-type">Math</span>.sqrt(n).toInt) exists (n % _ == <span class="hljs-number">0</span>))
  }
}
</code></pre>
<p>次にテストケースについて考えます。</p>
<ul>
<li>sum関数<ul>
<li>整数の配列を取得し、それらを足し合わせた整数を返すことができる</li>
<li>Intの最大を上回った際にはオーバーフローする</li>
</ul>
</li>
<li>div関数<ul>
<li>整数を2つ受け取り、分子を分母で割った浮動小数点の値を返す</li>
<li>0で割ろうとした際には実行時例外が投げられる</li>
</ul>
</li>
<li>isPrime関数<ul>
<li>その値が素数であるかどうかのブール値を返す</li>
<li>1000万以下の値の素数判定を一秒以内で処理できる</li>
</ul>
</li>
</ul>
<p>以上のようにテストを行います。基本的にテストの設計は、</p>
<ol>
<li>機能を満たすことをテストする</li>
<li>機能が実行できる境界値に対してテストする</li>
<li>例外やログがちゃんと出ることをテストする</li>
</ol>
<p>以上の考えが重要です。</p>
<p>XP（エクストリームプログラミング）のプラクティスに、不安なところを徹底的にテストするという考えがあり、基本それに沿います。</p>
<p>ひとつ目の満たすべき機能が当たり前に動くは当たり前のこととして、
2つ目の不安な要素のある境界値をしっかりテストする、というのはテストするケースを減らし、テストの正確性をあげるためのプラクティスの境界値テストとしても知られています。そして最後は、レアな事象ではあるけれど動かないと致命的な事象の取り逃しにつながる例外やログについてテストも非常に重要なテストです。このような例外やログにテストがないと例えば1か月に1度しか起こらないような不具合に対する対処が原因究明できなかったりと大きな問題につながってしまいます。</p>
<p>最小のテストを書いてみます。<code>src/test/scala/CalcSpec.scala</code>を以下のように記述します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> org.scalatest.flatspec.<span class="hljs-type">AnyFlatSpec</span>
<span class="hljs-keyword">import</span> org.scalatest.diagrams.<span class="hljs-type">Diagrams</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalcSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Diagrams</span> </span>{

  <span class="hljs-keyword">val</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-type">Calc</span>

  <span class="hljs-string">&quot;sum関数&quot;</span> should <span class="hljs-string">&quot;整数の配列を取得し、それらを足し合わせた整数を返すことができる&quot;</span> in {
    assert(calc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) === <span class="hljs-number">6</span>)
    assert(calc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-number">0</span>)) === <span class="hljs-number">0</span>)
    assert(calc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)) === <span class="hljs-number">0</span>)
    assert(calc.sum(<span class="hljs-type">Seq</span>()) === <span class="hljs-number">0</span>)
  }

  it should <span class="hljs-string">&quot;Intの最大を上回った際にはオーバーフローする&quot;</span> in {
    assert(calc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-type">Integer</span>.<span class="hljs-type">MAX_VALUE</span>, <span class="hljs-number">1</span>)) === <span class="hljs-type">Integer</span>.<span class="hljs-type">MIN_VALUE</span>)
  }
}
</code></pre>
<p>テストクラスに<code>Diagrams</code>をミックスインし、<code>assert</code>メソッドの引数に期待する条件を記述していきます<sup><a href="#fn_3" id="reffn_3">3</a></sup>。
<code>Diagrams</code>を使うことで、覚えるべきAPIを減らしつつテスト失敗時に多くの情報を表示できるようになります。</p>
<p>テストを実装したら<code>sbt test</code>でテストを実行してください。以下のような実行結果が表示されます。</p>
<pre><code>[info] Loading project definition from /Users/dwango/workspace/scalatest_study/project
[info] Set current project to scalatest_study (in build file:/Users/dwango/workspace/scalatest_study/)
[info] Compiling 1 Scala source to /Users/dwango/workspace/scalatest_study/target/scala-2.13/classes...
[info] Compiling 1 Scala source to /Users/dwango/workspace/scalatest_study/target/scala-2.13/test-classes...
[info] CalcSpec:
[info] sum関数
[info] - should 整数の配列を取得し、それらを足し合わせた整数を返すことができる
[info] - should Intの最大を上回った際にはオーバーフローする
[info] Run completed in 570 milliseconds.
[info] Total number of tests run: 2
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 12 s, completed 2015/12/25 1:25:56
</code></pre><p>実行結果から、すべてのテストに成功したことを確認できます。なお、わざと失敗した場合にはどのように表示されるのか確認してみましょう。</p>
<pre><code>[info] Loading project definition from /Users/dwango/workspace/scalatest_study/project
[info] Set current project to scalatest_study (in build file:/Users/dwango/workspace/scalatest_study/)
[info] Compiling 1 Scala source to /Users/dwango/workspace/scalatest_study/target/scala-2.13/test-classes...
[info] CalcSpec:
[info] sum関数
[info] - should 整数の配列を取得し、それらを足し合わせた整数を返すことができる *** FAILED ***
[info]   assert(calc.sum(Seq(1, 2, 3)) === 7)
[info]          |    |  ||   |  |  |   |   |
[info]          |    6  ||   1  2  3   |   7
[info]          |       |List(1, 2, 3) false
[info]          |       6
[info]          Calc@e72a964 (CalcSpec.scala:8)
[info] - should Intの最大を上回った際にはオーバーフローする
[info] Run completed in 288 milliseconds.
[info] Total number of tests run: 2
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 1, canceled 0, ignored 0, pending 0
[info] *** 1 TEST FAILED ***
[error] Failed tests:
[error]     CalcSpec
[error] (test:test) sbt.TestsFailedException: Tests unsuccessful
[error] Total time: 7 s, completed 2015/12/25 1:39:59
</code></pre><p>どこがどのように間違ったのかを指摘してくれます。</p>
<p>次に、例外が発生することをテストする場合について記述してみましょう。
div関数までテストの実装を進めます。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> org.scalatest.flatspec.<span class="hljs-type">AnyFlatSpec</span>
<span class="hljs-keyword">import</span> org.scalatest.diagrams.<span class="hljs-type">Diagrams</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalcSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Diagrams</span> </span>{

  <span class="hljs-keyword">val</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-type">Calc</span>

  <span class="hljs-comment">// ...</span>

  <span class="hljs-string">&quot;div関数&quot;</span> should <span class="hljs-string">&quot;整数を2つ受け取り、分子を分母で割った浮動小数点の値を返す&quot;</span> in {
    assert(calc.div(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>) === <span class="hljs-number">2.0</span>)
    assert(calc.div(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) === <span class="hljs-number">0.3333333333333333</span>)
  }

  it should <span class="hljs-string">&quot;0で割ろうとした際には実行時例外が投げられる&quot;</span> in {
    intercept[<span class="hljs-type">ArithmeticException</span>] {
      calc.div(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    }
  }
}
</code></pre>
<p>上記では最後の部分でゼロ除算の際に投げられる例外をテストしています。
<code>intercept[Exception]</code>という構文で作ったスコープ内で投げられる例外がある場合には成功となり、例外がない場合には逆にテストが失敗します。</p>
<p>最後にパフォーマンスを保証するテストを書きます。なお、本来ユニットテストは時間がかかるテストを書くべきではありませんが、できるだけ短い時間でそれを判定できるように実装します。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> org.scalatest.flatspec.<span class="hljs-type">AnyFlatSpec</span>
<span class="hljs-keyword">import</span> org.scalatest.diagrams.<span class="hljs-type">Diagrams</span>
<span class="hljs-keyword">import</span> org.scalatest.concurrent.<span class="hljs-type">TimeLimits</span>
<span class="hljs-keyword">import</span> org.scalatest.time.<span class="hljs-type">SpanSugar</span>._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalcSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Diagrams</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TimeLimits</span> </span>{

  <span class="hljs-keyword">val</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-type">Calc</span>

  <span class="hljs-comment">// ...</span>

  <span class="hljs-string">&quot;isPrime関数&quot;</span> should <span class="hljs-string">&quot;その値が素数であるかどうかのブール値を返す&quot;</span> in {
    assert(calc.isPrime(<span class="hljs-number">0</span>) === <span class="hljs-literal">false</span>)
    assert(calc.isPrime(<span class="hljs-number">-1</span>) === <span class="hljs-literal">false</span>)
    assert(calc.isPrime(<span class="hljs-number">2</span>))
    assert(calc.isPrime(<span class="hljs-number">17</span>))
  }

  it should <span class="hljs-string">&quot;1000万以下の値の素数判定を一秒以内で処理できる&quot;</span> in {
    failAfter(<span class="hljs-number">1000.</span>millis) {
      assert(calc.isPrime(<span class="hljs-number">9999991</span>))
    }
  }
}
</code></pre>
<p><code>TimeLimits</code>というトレイトを利用することで<code>failAfter</code>という処理時間をテストする機能を利用できるようになります。</p>
<p>最終的に全てのテストをまとめて<code>sbt test</code>で実行すると以下の様な出力が得られます。</p>
<pre><code>[info] Loading project definition from /Users/dwango/workspace/scalatest_study/project
[info] Set current project to scalatest_study (in build file:/Users/dwango/workspace/scalatest_study/)
[info] Compiling 1 Scala source to /Users/dwango/workspace/scalatest_study/target/scala-2.13/test-classes...
[info] CalcSpec:
[info] sum関数
[info] - should 整数の配列を取得し、それらを足し合わせた整数を返すことができる
[info] - should Intの最大を上回った際にはオーバーフローする
[info] div関数
[info] - should 整数を2つ受け取り、分子を分母で割った浮動小数点の値を返す
[info] - should 0で割ろうとした際には実行時例外が投げられる
[info] isPrime関数
[info] - should その値が素数であるかどうかのブール値を返す
[info] - should 1000万以下の値の素数判定を一秒以内で処理できる
[info] Run completed in 280 milliseconds.
[info] Total number of tests run: 6
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 6, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 8 s, completed 2015/12/25 1:43:22
</code></pre><p>以上が基本的なテストを実装するための機能の紹介でした。
BDDでテストを書くことによってテストによってどのような仕様が満たされた状態であるのかというのがわかりやすい状況になっていることがわかります。</p>
<h2 id="モック"><a name="モック" class="plugin-anchor" href="#モック"><i class="fa fa-link" aria-hidden="true"></i></a>モック</h2>
<p>モックとは、テストをする際に必要となるオブジェクトを偽装して用意できる機能です。以下の様なモックライブラリが存在しています。</p>
<ul>
<li><a href="https://scalamock.org/" target="_blank">ScalaMock</a></li>
<li><a href="https://easymock.org/" target="_blank">EasyMock</a></li>
<li><a href="http://jmock.org/" target="_blank">JMock</a></li>
<li><a href="https://github.com/mockito/mockito" target="_blank">Mockito</a></li>
</ul>
<p>ここでは、よく使われているMockitoを利用してみましょう。
<code>build.sbt</code>に以下を追記することで利用可能になります。</p>
<pre><code class="lang-scala">libraryDependencies += <span class="hljs-string">&quot;org.mockito&quot;</span> % <span class="hljs-string">&quot;mockito-core&quot;</span> % <span class="hljs-string">&quot;5.12.0&quot;</span> % <span class="hljs-string">&quot;test&quot;</span>
</code></pre>
<p>なお、mockitoのversion 5以降はJava 11以上が必要です。8を使用している場合はmockitoのversion 4を使ってください。</p>
<p>せっかくなので、先ほど用意したCalcクラスのモックを用意して、モックにsumの振る舞いを仕込んで見ましょう。</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> org.scalatest.time.<span class="hljs-type">SpanSugar</span>._
<span class="hljs-keyword">import</span> org.scalatest.flatspec.<span class="hljs-type">AnyFlatSpec</span>
<span class="hljs-keyword">import</span> org.scalatest.diagrams.<span class="hljs-type">Diagrams</span>
<span class="hljs-keyword">import</span> org.scalatest.concurrent.<span class="hljs-type">TimeLimits</span>
<span class="hljs-keyword">import</span> org.mockito.<span class="hljs-type">Mockito</span>._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalcSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFlatSpec</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Diagrams</span> <span class="hljs-keyword">with</span> <span class="hljs-title">TimeLimits</span> </span>{

  <span class="hljs-comment">// ...</span>

  <span class="hljs-string">&quot;Calcのモックオブジェクト&quot;</span> should <span class="hljs-string">&quot;振る舞いを偽装することができる&quot;</span> in {
    <span class="hljs-keyword">val</span> mockCalc = mock(classOf[<span class="hljs-type">Calc</span>])
    when(mockCalc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))).thenReturn(<span class="hljs-number">12</span>)
    assert(mockCalc.sum(<span class="hljs-type">Seq</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) === <span class="hljs-number">12</span>)
  }
}
</code></pre>
<p><code>val mockCalc = mock(classOf[Calc])</code>でモックオブジェクトを作成し、
<code>when(mockCalc.sum(Seq(3, 4, 5)).thenReturn(12)</code>で振る舞いを作成しています。</p>
<p>そして最後に、<code>assert(mockCalc.sum(Seq(3, 4, 5)) === 12)</code>でモックに仕込んだ偽装された振る舞いをテストしています。</p>
<p>以上のようなモックの機能は、実際には時間がかかってしまう通信などの部分を高速に動かすために利用されています。</p>
<p>モックを含め、テストの対象が依存しているオブジェクトを置き換える代用品の総称をテストダブル<sup><a href="#fn_4" id="reffn_4">4</a></sup>と呼びます。</p>
<h2 id="コードカバレッジの測定"><a name="コードカバレッジの測定" class="plugin-anchor" href="#コードカバレッジの測定"><i class="fa fa-link" aria-hidden="true"></i></a>コードカバレッジの測定</h2>
<p>テストを行った際に、テストが機能のどれぐらいを網羅できているのかを知る方法として、コードカバレッジを計測するという方法があります。ここでは、<a href="https://github.com/scoverage/scalac-scoverage-plugin" target="_blank">scoverage</a>を利用します。</p>
<p><code>project/plugins.sbt</code> に以下のコードを記述します。</p>
<pre><code class="lang-scala">addSbtPlugin(<span class="hljs-string">&quot;org.scoverage&quot;</span> % <span class="hljs-string">&quot;sbt-scoverage&quot;</span> % <span class="hljs-string">&quot;2.0.3&quot;</span>)
</code></pre>
<p>その後、<code>sbt clean coverage test coverageReport</code>を実行することで、<code>target/scala-2.13/scoverage-report/index.html</code>にレポートが出力されます。</p>
<p><img src="img/scoverage_code_coverage.png" alt="Scoverage Code Coverage"></p>
<p>以上の出力から、今回のテストはカバレッジ100％であることがわかります。</p>
<p>ここで、カバレッジを計測することについて注意点を述べておきます。</p>
<p>得られたカバレッジはあくまで”そのカバレッジツールによって得られた数値”でしかありません。数値自体が絶対的な評価を表しているわけではなく、書かれたプロダクトコードに対して、テストコードがN％カバーしているという事実を示しているだけです。カバレッジはツールや測定手法によって結果が変動します。例えばJavaScript用のカバレッジツールであるistanbulは<a href="https://github.com/gotwarlost/istanbul/blob/v0.4.3/lib/object-utils.js#L93" target="_blank">totalが0件の場合100%と表示します</a>が、これは単にツールの実装がそうなっているというだけの話です。</p>
<p>利用しているカバレッジツールがどのように動作するのか把握した上で、カバレッジレポートからどのコードが実行されなかったのか情報収集しましょう。数値だけに目を向けるのではなく、カバレッジ測定によってどういった情報が得られたのかを考えてください。そうすれば、ツールに振り回されることなくテストの少ない部分を発見できるでしょう。</p>
<h2 id="コードスタイルチェック"><a name="コードスタイルチェック" class="plugin-anchor" href="#コードスタイルチェック"><i class="fa fa-link" aria-hidden="true"></i></a>コードスタイルチェック</h2>
<p>なおテストとは直接は関係ありませんが、ここまでで紹介したテストは、実際にはJenkinsなどの継続的インテグレーションツール（CIツール）で実施され、リグレッションを検出するためにつかわれます。その際に、CIの一環として一緒に行われることが多いのがコードスタイルチェックです。</p>
<p>コードスタイルチェックにおいて、インデントの数や定義の前後のスペースなどコードのフォーマットをチェックするにはフォーマッタを、静的解析で推奨されるScalaコードの書き方になっているかをチェックするにはリンターを使います。例えば、次のメソッド定義はProcedure Syntaxと呼ばれ、比較的新しいバージョンのScalaでは非推奨になっています。リンターはこのような望ましくないコードを検知して報告します。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Example</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myProcedure</span> </span>{}
}
</code></pre>
<p>2022年現在では<a href="https://scalameta.org/scalafmt/" target="_blank">scalafmt</a>がデファクトのフォーマッタとして、<a href="https://scalacenter.github.io/scalafix/" target="_blank">scalafix</a>や<a href="https://github.com/wartremover/wartremover" target="_blank">wartremover</a>がリンターとして使われています。scalafmt、scalafix、wartremoverはScala 3に対応しています。
scalafmt、scalafixのどちらもコードスタイルチェックに加えて自動修正機能があります。</p>
<p>scalafmt、scalafixはCLIでもsbt pluginでも使えますがここではsbt pluginを利用する前提で話をすすめます。</p>
<p><code>project/plugins.sbt</code> に以下のコードを記述します。</p>
<pre><code class="lang-scala">addSbtPlugin(<span class="hljs-string">&quot;org.scalameta&quot;</span> %% <span class="hljs-string">&quot;scalafmt&quot;</span> % <span class="hljs-string">&quot;&lt;latest&gt;&quot;</span>)
addSbtPlugin(<span class="hljs-string">&quot;ch.epfl.scala&quot;</span> % <span class="hljs-string">&quot;sbt-scalafix&quot;</span> % <span class="hljs-string">&quot;&lt;latest&gt;&quot;</span>)
</code></pre>
<h3 id="scalafmt"><a name="scalafmt" class="plugin-anchor" href="#scalafmt"><i class="fa fa-link" aria-hidden="true"></i></a>scalafmt</h3>
<p>まずはscalafmtを試してみましょう。sbtシェルを開いて次のコマンドを実行してください。もしソースにフォーマットに問題があるコードが含まれているなら警告が表示されます。</p>
<pre><code class="lang-sh">scalafmtCheckAll
</code></pre>
<p>次のコマンドを実行するとフォーマットを自動的に修正します。</p>
<pre><code class="lang-sh">scalafmtAll
</code></pre>
<p>また、<code>build.sbt</code>などのビルドにつかうScalaファイルのフォーマットは<code>scalafmtSbt</code>で修正できます。</p>
<p>フォーマットは<code>.scalafmt.conf</code>ファイルで設定できます。詳しくは公式ドキュメントにひととおり目を通してみるといいでしょう。
<a href="https://scalameta.org/scalafmt/docs/configuration.html" target="_blank">https://scalameta.org/scalafmt/docs/configuration.html</a></p>
<h3 id="scalafix"><a name="scalafix" class="plugin-anchor" href="#scalafix"><i class="fa fa-link" aria-hidden="true"></i></a>scalafix</h3>
<p>さて、次はscalafixを試してみましょう。
sbtシェルで次のコマンドを実行してください。</p>
<pre><code class="lang-sh">scalafix --check --rules ProcedureSyntax
</code></pre>
<p>下記のように警告が表示されます。</p>
<pre><code>[info] Running scalafix on 1 Scala sources
[error] --- /path/to/problematic/File.scala
[error] +++ &lt;expected fix&gt;
...省略...
[error] -  def myProcedure {}
[error] +  def myProcedure: Unit = {}
[error]  
...省略...
[error] 
ScalafixFailed: TestError
</code></pre><p>問題のあるコードを自動的に書き換えるには<code>--check</code>オプションを外して<code>scalafix ProcedureSyntax</code>コマンドを実行します。先ほどの<code>myProcedure</code>は次のように修正されます。</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Example</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myProcedure</span></span>: <span class="hljs-type">Unit</span> = {}
}
</code></pre>
<p>Procedure Syntaxの警告と修正はscalafixにデフォルトで用意されていますが、ライブラリとして公開されているscalafixのルールを使うことでリンターのルールを追加できます。公開されているルールは<a href="https://scalacenter.github.io/scalafix/docs/rules/community-rules.html" target="_blank">scalafixのドキュメント</a>に書いてあります。</p>
<h2 id="テストを書こう"><a name="テストを書こう" class="plugin-anchor" href="#テストを書こう"><i class="fa fa-link" aria-hidden="true"></i></a>テストを書こう</h2>
<p>開発者として意識してほしいことを挙げておきます。</p>
<ul>
<li>不具合を見つけたら、可能であれば再現手順もあわせて報告する</li>
<li>パッチを送る際はテストを含める</li>
<li><a href="https://t-wada.hatenablog.jp/entry/debugging-tests" target="_blank">不具合にテストを書いて立ち向かう</a></li>
</ul>
<p>他人から報告された不具合は、伝聞ということもありどうしても再現させづらい場合があります。その結果として「私の環境では再現しませんでした」と言われて終わってしまうのでは、不具合を修正するせっかくのチャンスを逃すことになってしまいます。そんな状況を回避するためにも、可能であれば不具合の再現手順や再現コードを用意し、不具合報告に含めましょう。再現手順を元に素早く不具合が修正される可能性が高まります。</p>
<p>他人のコードをテストするのは、ちょっとしたコードであっても骨の折れる作業です。そんな作業を、限られたリソースですべてのパッチに対して行うのは不可能に近いので、プロジェクトによってはテストコードのないパッチはレビュー対象から外すことが多いです。パッチを送る場合は相手側が自信を持ってパッチを取り込めるよう、テストを含めておきましょう。</p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="http://jstqb.jp/dl/JSTQB-glossary-introduction.V3.2.J01.pdf" target="_blank">http://jstqb.jp/dl/JSTQB-glossary-introduction.V3.2.J01.pdf</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 渡された条件式の実行過程をダイアグラムで表示する<code>assert</code>は、一般に“power assert”と呼ばれています<a href="#reffn_2" title="Jump back to footnote [2] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. Scalaには<code>Predef</code>にも<code>assert</code>が存在しますが、基本的に使うことはありません<a href="#reffn_3" title="Jump back to footnote [3] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. モック以外の仕組みについては<a href="http://xunitpatterns.com/" target="_blank">xUnit Test Patterns</a>を参照してください<a href="#reffn_4" title="Jump back to footnote [4] in the text."> ↩</a>
</blockquote>
</body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="future-and-promise.html" class="navigation navigation-prev " aria-label="Previous page: FutureとPromise">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="java-interop.html" class="navigation navigation-next " aria-label="Next page: Javaとの相互運用">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"テスト","level":"1.20","depth":1,"next":{"title":"Javaとの相互運用","level":"1.21","depth":1,"path":"java-interop.md","ref":"java-interop.md","articles":[]},"previous":{"title":"FutureとPromise","level":"1.19","depth":1,"path":"future-and-promise.md","ref":"future-and-promise.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-codeblock","japanese-support","footnote-string-to-number","anchors","regexplace","forkmegithub"],"root":"./honkit","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"regexplace":{"substitutes":[{"pattern":"<!-- begin answer id=\"(.*)\" style=\"(.*)\" -->","flags":"g","substitute":"<div><button type=\"button\" id=\"$1_show_answer_button\" style=\"display:block\" onclick=\"document.getElementById('$1').style.display='block'; document.getElementById('$1_show_answer_button').style.display='none'; document.getElementById('$1_hide_answer_button').style.display='block'; \">解答例を表示する</button><button type=\"button\" id=\"$1_hide_answer_button\" style=\"display:none\" onclick=\"document.getElementById('$1').style.display='none'; document.getElementById('$1_show_answer_button').style.display='block'; document.getElementById('$1_hide_answer_button').style.display='none'; \">解答例を隠す</button></div><div id=\"$1\" style=\"$2\">"},{"pattern":"<!-- end answer -->","flags":"g","substitute":"</div>"}]},"search":{},"footnote-string-to-number":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"japanese-support":{},"highlight":{},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"default","theme":"chrome","unindent":false},"forkmegithub":{"color":"darkblue","url":"https://github.com/scala-text/scala_text"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"INTRODUCTION.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Scala研修テキスト","gitbook":"*"},"file":{"path":"test.md","mtime":"2024-08-19T21:23:41.038Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-19T21:23:43.894Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-forkmegithub/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

